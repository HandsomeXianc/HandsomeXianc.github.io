<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring技术AOP基础</title>
    <url>/2023/10/03/AOP%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="AOP基础"><a href="#AOP基础" class="headerlink" title="AOP基础"></a>AOP基础</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ul>
<li><b style="color:red">AOP：</b><span style="color:red">A</span>spect <span style="color:red">O</span>riented <span style="color:red">P</span>rogramming（<span style="color:red">面向切面编程，面向方面编程</span>），其实就是面向特定的方法编程。</li>
<li><strong>动态代理</strong>是面向切面编程最主流的实现。而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。</li>
<li><strong>使用场景</strong>：记录操作日志、权限控制、事务管理…</li>
<li><strong>优势</strong>：代码无侵入、减少重复代码、提高开发效率、维护方便</li>
</ul>
<h2 id="二、SpringAOP快速入门"><a href="#二、SpringAOP快速入门" class="headerlink" title="二、SpringAOP快速入门"></a>二、SpringAOP快速入门</h2><p><strong>问题：统计各个业务层方法的执行耗时</strong></p>
<ol>
<li><p>导入依赖</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>编写AOP程序：针对特定的方法根据业务需要进行编程</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>              <span class="comment">//日志打印</span></span><br><span class="line"><span class="meta">@Component</span>          <span class="comment">//交给IOC管理</span></span><br><span class="line"><span class="meta">@Aspect</span>             <span class="comment">//告知Spring这是一个AOP</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.mystudy.service.*.*(..))&quot;)</span>     <span class="comment">//说明该切面作用在那些方法上</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">recordTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//1. 记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//2. 调用原始方法执行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();    <span class="comment">//result是原始方法执行之后的返回值</span></span><br><span class="line">        <span class="comment">//3. 记录结束时间，计算方法执行耗时</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(joinPoint.getSignature()+<span class="string">&quot;执行耗时:&#123;&#125;ms&quot;</span>,end - begin);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时，访问各个接口可以看到结果，说明实现成功…</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309251852023.png"
                      alt="image-20230925185240803"
                ></p>
</li>
</ol>
<h2 id="三、核心概念"><a href="#三、核心概念" class="headerlink" title="三、核心概念"></a>三、核心概念</h2><ul>
<li><strong>连接点</strong>：JoinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息）</li>
<li><strong>通知</strong>：Advice，指哪些重复的逻辑，也就是共性功能（最终体现为一个方法）</li>
<li><strong>切入点</strong>：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用</li>
<li><strong>切面</strong>：Aspect，描述通知与切入点的对应关系（通知 + 切入点）</li>
<li><strong>目标对象</strong>：Target，通知所应用的对象</li>
</ul>
<h2 id="四、通知类型"><a href="#四、通知类型" class="headerlink" title="四、通知类型"></a>四、通知类型</h2><ol>
<li><code>Around</code>：环绕通知，此注解标注的通知方法在目标方法前、后被执行</li>
<li><code>Before</code>：前置通知，此注解标注的通知方法在目标方法前被执行</li>
<li><code>After</code>：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会被执行</li>
<li><code>AfterReturning</code>：返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行</li>
<li><code>@AfterThrowing</code>：异常后通知，次注解标注的通知方法发生异常后执行</li>
</ol>
<blockquote>
<p><b style="color:red">注意事项</b></p>
<ul>
<li><code>@Aroudn</code>环绕通知需要自己调用 **ProceedingJoinPoint.proceed( )**来让原始方法执行，其他通知不需要考虑目标方法执行。</li>
<li><code>@Around</code>环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值。</li>
</ul>
</blockquote>
<hr>

<p><strong>测试代码展示</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>              <span class="comment">//日志打印</span></span><br><span class="line"><span class="meta">@Component</span>          <span class="comment">//交给IOC管理</span></span><br><span class="line"><span class="meta">@Aspect</span>             <span class="comment">//告知Spring这是一个AOP</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.mystudy.service.impl.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;前置通知：before..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.mystudy.service.impl.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;环绕通知...前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        log.info(<span class="string">&quot;环绕通知...后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.mystudy.service.impl.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;后置通知：after..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行之后，查看结果。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309251940219.png"
                      alt="image-20230925194011078"
                ></p>
<p><strong>回过头来看看我们编辑的代码，每一个切入点都包含一个重复的切入点表达式，这样会显得代码繁琐，因此可以使用注解<code>@Pointcut</code>简化</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>              <span class="comment">//日志打印</span></span><br><span class="line"><span class="meta">@Component</span>          <span class="comment">//交给IOC管理</span></span><br><span class="line"><span class="meta">@Aspect</span>             <span class="comment">//告知Spring这是一个AOP</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.mystudy.service.impl.UserServiceImpl.*(..))&quot;)</span>	<span class="comment">//定义切入点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span>			<span class="comment">//使用切入点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;前置通知：before..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span>			<span class="comment">//使用切入点</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;环绕通知...前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        log.info(<span class="string">&quot;环绕通知...后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span>			<span class="comment">//使用切入点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;后置通知：after..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<hr>

<p><strong>不同切面类之间定义的<span style="color:blue">切入点</span>是可以<span style="color:red">共享</span>的</strong></p>
<ol>
<li><p>首先在<code>TimeAspect</code>类中定义一个切入点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309251951765.png"
                      alt="image-20230925195156608"
                ></p>
</li>
<li><p>在<code>MyAspect</code>类中使用<code>TimeAspect</code>的切入点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309251952910.png"
                      alt="image-20230925195226775"
                ></p>
</li>
<li><p>启动项目查看运行结果：MyAspect的切入成功实现即可说明切入点可以共享</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309251953999.png"
                      alt="image-20230925195329895"
                ></p>
</li>
</ol>
<hr>



<h2 id="五、通知顺序"><a href="#五、通知顺序" class="headerlink" title="五、通知顺序"></a>五、通知顺序</h2><ul>
<li><strong>场景：当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行</strong></li>
</ul>
<p>这里我定义了三个切面类并且实现了对应的<code>@Before</code>和<code>@After</code></p>
<center class="half">    
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309252017184.png"
                      width="310"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309252017013.png"
                      width="310"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309252017835.png"
                      width="310"
                >
</center>

<p>运行程序之后，发送一个请求，查看切面的运行结果为下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309252021087.png"
                      alt="image-20230925202156024"
                ></p>
<p>发现规律：与<b style="color:red">切面类的类名</b>相关</p>
<ul>
<li>不同切面类中，默认按照切面类的<b style="color:red">类名字母排序</b><ol>
<li>在原始方法运行<b style="color:blue">之前</b>的通知：类名排名越靠前<b style="color:green">越先执行</b></li>
<li>在原始方法运行<b style="color:blue">之后</b>的通知：类名排名越靠前<b style="color:green">越后执行</b></li>
</ol>
</li>
<li>使用<code>@Order(数字)</code>加在切面类上来控制顺序<ol>
<li>在原始方法运行<b style="color:blue">之前</b>的通知：数字小的<b style="color:green">越先执行</b></li>
<li>在原始方法运行<b style="color:blue">之后</b>的通知：数字小的<b style="color:green">越后执行</b></li>
</ol>
</li>
</ul>
<p><strong>例子：使用@Order来指定先让Aop_2的前置通知先执行，然后是Aop_3最后执行Aop_1</strong></p>
<ul>
<li>首先在对应的Aop类上加上注解@Order注解因为先执行Aop_2所以它的 数字最小</li>
</ul>
<center class="half">    
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309252044370.png"
                      width="310"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309252045483.png"
                      width="310"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309252045653.png"
                      width="310"
                >
</center>

<ul>
<li>启动程序，发送请求，查看结果。结果与注解@Order相对应</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309252051599.png"
                     
                >

<hr>

<h2 id="六、切入点表达式"><a href="#六、切入点表达式" class="headerlink" title="六、切入点表达式"></a>六、切入点表达式</h2><ul>
<li><p><strong>切入点表达式</strong>：描述切入点方法的一种表达式</p>
</li>
<li><p><strong>作用</strong>：主要用来决定项目中的哪些方法需要加入通知</p>
</li>
<li><p><strong>常见形式</strong>：</p>
<ol>
<li><code>execution(...)</code>：根据方法的签名来匹配</li>
<li><code>@annotation(...)</code>：根据注解匹配</li>
</ol>
</li>
</ul>
<h4>第一类：execution</h4>

<p>execution 主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) <span class="keyword">throws</span> 异常?)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>其中带 <b style="color:red">?</b> 表示可以省略的部分<ul>
<li>访问修饰符：可省略（比如：public、protected）</li>
<li>包名.类名：可省略</li>
<li>throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(public void com.mystudy.service.impl.UserServiceImpl.delete(java.lang.Integer))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JointPoint joinPoint)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>可以使用通配符描述切入点</p>
<ol>
<li><p><code>*</code>：<strong>单个独立</strong>的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类方法名的一部分</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">execution(* com.*.service.*.update*(*))</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>..</code>：<strong>多个连续</strong>的任意符号，可以通配任意层级的包、或任意类型、任意个数的参数</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">execution(* com.itheima..DeptService.*(..))</span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>注意事项：</strong></p>
<ul>
<li>根据业务需要，可以使用 且(&amp;&amp;)、或(||)、非(!)来组合比较复杂的切入点表达式</li>
</ul>
<p><strong>书写建议：</strong></p>
<ul>
<li>所有业务<span style="color:red">方法名</span>在<span style="color:red">命名</span>时尽量<span style="color:red">规范</span>，方便切入点表达式的快速匹配。如：查询类方法都是find开头，更新类方法都是update开头</li>
<li>描述切入点方法通常是<span style="color:red">基于接口描述</span>，而不是直接描述实现类，<span style="color:red">增强拓展性</span></li>
<li>在满足业务需要的前提下，<span style="color:red">尽量缩小切入点的匹配范围</span>。如：包名匹配尽量不使用<code>..</code>，使用<code>*</code>匹配单个包</li>
</ul>
</blockquote>
<hr>

<h4>第二类：@annotation【基于注解开发】</h4>

<p><strong>首先定义一个注解</strong></p>
<ul>
<li>**<code>@Retention</code>**：该注解用来说明自定义注解在什么时候生效</li>
<li>**<code>@Target</code>**：用于描述注解在哪里生效</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309260932197.png"
                      alt="image-20230926093159391"
                ></p>
<p><strong>然后，修改<code>MyAspect</code>的内容将注解<code>@Around</code>中的内容更换成<code>@annotation(&quot;自定义注解所在的包&quot;)</code></strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309260933011.png"
                      alt="image-20230926093347797"
                ></p>
<p><strong>在需要使用到MyAspect切面的地方添加上自定义注解<code>@MyAnnotation</code>【此处我在Login上添加注解】然后启动项目，测试结果</strong></p>
<center class="half">    
        <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309260938941.png"
                      width="300" style="height:150px"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309260938534.png"
                      width="630" style="height:150px"
                >
</center>

<p><strong>可以看到在执行<code>Login</code>的时候切面类<code>MyAspect</code>确实也执行了说明基于自定义注解<code>@annotation</code>成功实现</strong></p>
<hr>



<h2 id="七、连接点"><a href="#七、连接点" class="headerlink" title="七、连接点"></a>七、连接点</h2><ul>
<li>在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如<strong>目标类名、方法名、方法参数等</strong><ul>
<li>对于<code>@Around</code>通知，获取连接点信息只能使用 <code>ProceedingJoinPoint</code></li>
<li>对于其它四种通知，获取连接点信息只能使用<code>JoinPoint</code>，它是<code>ProceedingJoinPoint</code>的父类型</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.mystudy.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//1. 获取目标的类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line">        log.info(<span class="string">&quot;目标类名:&#123;&#125;&quot;</span>,name);</span><br><span class="line">        <span class="comment">//2. 获取目标方法的签名</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        log.info(<span class="string">&quot;目标方法签名:&#123;&#125;&quot;</span>,signature);</span><br><span class="line">        <span class="comment">//3. 获取目标的方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sname</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        log.info(<span class="string">&quot;目标方法名：&#123;&#125;&quot;</span>,sname);</span><br><span class="line">        <span class="comment">//4. 获取目标方法运行参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        log.info(<span class="string">&quot;运行参数:&#123;&#125;&quot;</span>,args);</span><br><span class="line">        <span class="comment">//5. 执行原始方法，获取返回值(环绕通知)</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>







<h2 id="八、操作例子"><a href="#八、操作例子" class="headerlink" title="八、操作例子"></a>八、操作例子</h2><p><strong>下面给出一个具体业务实际的操作例子来巩固AOP操作，具体场景如下：</strong>在实际开发中常常会遇到对数据库的修改以及添加操作，在某些时刻每一次添加以及修改的操作的时候需要记录下操作人以及操作时间，因此在很多方法上会有冗余的代码【即：记录操作人以及修改时间】，此类问题称为公共字段填充。</p>
<p><strong>实现思路</strong></p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">字段名</th>
<th align="center">含义</th>
<th align="center">数据类型</th>
<th align="center">操作类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">create_time</td>
<td align="center">创建时间</td>
<td align="center">datetime</td>
<td align="center">insert</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">create_user</td>
<td align="center">创建人id</td>
<td align="center">bigint</td>
<td align="center">insert</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">update_time</td>
<td align="center">修改时间</td>
<td align="center">datetime</td>
<td align="center">insert、update</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">update_user</td>
<td align="center">修改人id</td>
<td align="center">bigint</td>
<td align="center">insert、update</td>
</tr>
</tbody></table>
<ul>
<li>自定义注解AutoFill，用于标识需要进行公共字段自动填充的方法</li>
<li>自定义切面类AutoFillAspect，统一拦截加入AutoFill注解的方法，通过反射为公共字段赋值</li>
<li>在Mapper的方法上加入AutoFill注解</li>
</ul>
<blockquote>
<p>技术点：枚举、注解、AOP、反射</p>
</blockquote>
<p><strong>在清楚操作步骤之后，现在开始实现上述的过程</strong></p>
<ul>
<li>首先自定义注解</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解,用于标识某个方法需要进行功能字段的自动填充处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoFill &#123;</span><br><span class="line">    <span class="comment">//标识数据库操作类型： UPDATE INSERT</span></span><br><span class="line">    OperationType <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>自定义切面类之前，首先创建一个constant保存字符串【利于后期统一修改用到字符串的地方】</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoFillConstant</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实体类中的方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SET_CREATE_TIME</span> <span class="operator">=</span> <span class="string">&quot;setCreateTime&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SET_UPDATE_TIME</span> <span class="operator">=</span> <span class="string">&quot;setUpdateTime&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SET_CREATE_USER</span> <span class="operator">=</span> <span class="string">&quot;setCreateUser&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SET_UPDATE_USER</span> <span class="operator">=</span> <span class="string">&quot;setUpdateUser&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后就可以开始定义切面类</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义切面类，实现公共字段的自动填充处理逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoFillAspect</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFillPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知，为公共字段赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;autoFillPointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFill</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;开始进行公共字段自动填充&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前被拦截的方法上的数据库操作类型</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature)joinPoint.getSignature();<span class="comment">//方法签名对象</span></span><br><span class="line">        <span class="type">AutoFill</span> <span class="variable">annotation</span> <span class="operator">=</span> signature.getMethod().getAnnotation(AutoFill.class);</span><br><span class="line">        <span class="type">OperationType</span> <span class="variable">operationType</span> <span class="operator">=</span> annotation.value();<span class="comment">//获取数据库的操作类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前被拦截的方法参数--实体对象</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">if</span>(args == <span class="literal">null</span> || args.length == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">entity</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//准备赋值的数据</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据当前不同的操作类型,为对应的属性通过反射来赋值</span></span><br><span class="line">        <span class="keyword">if</span>(operationType == OperationType.INSERT)&#123;</span><br><span class="line">            <span class="comment">//为四个公共字段赋值</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);</span><br><span class="line"></span><br><span class="line">                setCreateTime.invoke(entity,now);</span><br><span class="line">                setUpdateTime.invoke(entity,now);</span><br><span class="line">                setCreateUser.invoke(entity,currentId);</span><br><span class="line">                setUpdateUser.invoke(entity,currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(operationType == OperationType.UPDATE)&#123;</span><br><span class="line">            <span class="comment">//为更新时间和更新人ID进行赋值</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);</span><br><span class="line"></span><br><span class="line">                setUpdateTime.invoke(entity,now);</span><br><span class="line">                setUpdateUser.invoke(entity,currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>随后在需要进行公共字段填充的地方添加上自定义的注解即可</li>
</ul>
]]></content>
      <categories>
        <category>常见技术问题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
        <tag>spring全家桶</tag>
      </tags>
  </entry>
  <entry>
    <title>Git操作入门</title>
    <url>/2023/09/17/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Git快速入门"><a href="#Git快速入门" class="headerlink" title="Git快速入门"></a>Git快速入门</h1><h2 id="1-克隆远程项目到本地文件夹"><a href="#1-克隆远程项目到本地文件夹" class="headerlink" title="1.  克隆远程项目到本地文件夹"></a>1.  克隆远程项目到本地文件夹</h2><ul>
<li>先创建一个空的文件夹，如何使用 git bush 命令</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone 仓库地址</span><br><span class="line">示例： git clone https://gitee.com/Xc_cc/java2021net20213902009.git</span><br></pre></td></tr></table></figure></div>

<h2 id="2-修改文件并提交到本地仓库"><a href="#2-修改文件并提交到本地仓库" class="headerlink" title="2.  修改文件并提交到本地仓库"></a>2.  修改文件并提交到本地仓库</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add [被修改的文件]				此步操作需要先cd 进入修改文件的同级目录</span><br><span class="line">git commit			会进入到vim编辑器提示你写入注释</span><br><span class="line">使用 git commit -m &#x27;注释&#x27;	可以不用进入vim编辑器直接添加注释并提交</span><br></pre></td></tr></table></figure></div>

<h2 id="3-推送到远程仓库"><a href="#3-推送到远程仓库" class="headerlink" title="3.  推送到远程仓库"></a>3.  推送到远程仓库</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log 显示提交的记录日志</span><br><span class="line">git push	提交到远程仓库</span><br></pre></td></tr></table></figure></div>

<h2 id="4-1-忽略版本跟踪"><a href="#4-1-忽略版本跟踪" class="headerlink" title="4.1 忽略版本跟踪"></a>4.1 忽略版本跟踪</h2><ul>
<li>如果有哪些文件是在文件上传到仓库的时候是不需要上传的则需要使用忽略版本跟踪</li>
</ul>
<ol>
<li><p>在 项目根目录创建 <code>.gitignore</code> 文件</p>
</li>
<li><p>用文本编辑器打开文件，进行配置：</p>
<ul>
<li><p>每项配置独占一行</p>
</li>
<li><p>每行的内容可以是：文件&#x2F;目录 的<code>名称</code>，<code>路径</code>或是的<code>模式匹配</code></p>
</li>
</ul>
</li>
</ol>
<h2 id="4-2-gitignore忽略文件的版本跟踪"><a href="#4-2-gitignore忽略文件的版本跟踪" class="headerlink" title="4.2 gitignore忽略文件的版本跟踪"></a>4.2 gitignore忽略文件的版本跟踪</h2><p><strong>模式匹配</strong>：</p>
<ol>
<li><strong>空行</strong>不匹配任何文件，因此常用作分隔符（方便阅读）</li>
<li><span style="color:red">#</span>用于注释，<span style="color:red"> \ </span>表示转义（如需实体 \ 则需要添加引号”<span style="color:red"> \ </span>“）</li>
<li><span style="color:red">*</span>可以匹配任何字符串（0或多次），<span style="color:red">？</span>可以匹配任何字符（1次）。（注意：他们都不可以匹配<span style="color:red">  \ </span>）</li>
<li>原来被排除的文件使用<span style="color:red"> ！</span>模式之后该文件会重新被包含。但是如果该文件的父级目录被排除了，那么使用<span style="color:red">！</span>也不会再次被包含</li>
<li><span style="color:red">[ ]</span>通常用于匹配一个字符列表，如：a[mn]z可以匹配 amz 和anz</li>
<li><span style="color:red">**</span>用于匹配多级目录，如a &#x2F; * *&#x2F;可以匹配 “a&#x2F;b” , “a&#x2F;x&#x2F;b” , “a&#x2F;x&#x2F;y&#x2F;b” 等等。</li>
</ol>
<h2 id="5-如何检查ignore规则有效性"><a href="#5-如何检查ignore规则有效性" class="headerlink" title="5. 如何检查ignore规则有效性"></a>5. 如何检查ignore规则有效性</h2><p>使用命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git check-ignore -v &#123;文件或目录路径&#125;</span><br></pre></td></tr></table></figure></div>

<p>若是使用命令之后有输出，说明该文件已被忽略。</p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p><code>.gitignore </code>只能忽略那些没有被追踪的文件，所以先纳入版本管理后写入的<code>.gitignore</code> 是无效的。</p>
<p><strong>解决方法：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">先修改 .gitignore 文件，之后执行以下内容</span><br><span class="line">git rm -r --cached .</span><br><span class="line">git add . </span><br><span class="line">git status</span><br></pre></td></tr></table></figure></div>

<p>同样的，已被<code>.gitignore</code>忽略的文件也是无法加入版本库的</p>
<p><strong>解决方法：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">先在 .gitignore 中移除掉需要重新纳入版本追踪的文件再使用</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure></div>

<h2 id="6-从版本库中恢复文件"><a href="#6-从版本库中恢复文件" class="headerlink" title="6. 从版本库中恢复文件"></a>6. 从版本库中恢复文件</h2><ol>
<li><p>文件恢复（一）：修改或删除之后，没有<code>add</code>过的文件恢复。</p>
<p><strong>解决方法：</strong>使用 <code>git checkout 文件名</code>命令即可</p>
</li>
<li><p>文件恢复（二）：有<code>add</code>，但无<code>commit</code>过的文件恢复</p>
<p><strong>解决方法：</strong>先用 <code>git log</code>查看日志，获取需要恢复的版本commit的<code>id</code></p>
<p>​						 然后使用<code>git checkout &lt;commitid&gt; &lt;文件路径&gt;</code>命令即可</p>
<p>​	 					<strong>表示：</strong>从某个 commit 状态中 恢复文件到工作区</p>
</li>
<li><p>文件恢复（三）：已 commit 的文件，恢复到之前的版本</p>
<p><strong>解决方法：</strong>使用<code>git checkout &lt;commitid&gt; &lt;文件路径&gt;</code>命令即可，同第二种情况一样</p>
</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis入门</title>
    <url>/2023/10/07/Redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis是一个基于<strong>内存</strong>的key-value结构的数据库</p>
<ul>
<li>基于内存存储，读写性能高</li>
<li>适合存储热点数据（热点商品、咨询、新闻）【访问频繁】</li>
<li>企业应用广泛</li>
</ul>
<h2 id="5种常用的数据类型介绍"><a href="#5种常用的数据类型介绍" class="headerlink" title="5种常用的数据类型介绍"></a>5种常用的数据类型介绍</h2><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型</p>
<ul>
<li>字符串 string</li>
<li>哈希 hash</li>
<li>列表 list</li>
<li>集合 set</li>
<li>有序集合 sorted set &#x2F; zset</li>
</ul>
<h2 id="各种数据类型的特点"><a href="#各种数据类型的特点" class="headerlink" title="各种数据类型的特点"></a>各种数据类型的特点</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309081447840.jpg"
                      alt="processon"
                ></p>
<ul>
<li><strong>字符串</strong>：普通字符串，redis中最简单的数据类型</li>
<li><strong>哈希</strong>：散列表，类似Java中的HashMap结构</li>
<li><strong>列表</strong>：按照插入的顺序排序，可以有重复的元素，类似Java中的LinkedList</li>
<li><strong>集合</strong>：无序集合，没有重复元素，类似Java中的HashSet</li>
<li><strong>有序集合</strong>：集合中每个元素关联一个分数，根据分数升序排序，没有重复元素</li>
</ul>
<h2 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h2><h3 id="字符串操作命令"><a href="#字符串操作命令" class="headerlink" title="字符串操作命令"></a>字符串操作命令</h3><ul>
<li><code>SET key value</code>：设置指定key的值</li>
<li><code>GET key</code>：获取指定key的值</li>
<li><code>SETEX key seconds value</code>：设置指定key的值，并将key的过期时间设置为seconds秒</li>
<li><code>SETNX key value</code>：只有key不存在时设置key的值</li>
</ul>
<h3 id="哈希操作命令"><a href="#哈希操作命令" class="headerlink" title="哈希操作命令"></a>哈希操作命令</h3><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p>
<ul>
<li><code>HSET key field value</code> ：将哈希表key中的字段field的值设置为value</li>
<li><code>HGET key field</code>：获取存储在哈希表中指定字段的值</li>
<li><code>HDEL key field</code>：删除存储在哈希表中的指定字段</li>
<li><code>HKEYS key</code>：获取哈希表中所有字段</li>
<li><code>HVALS key</code>：获取哈希表中所有值</li>
</ul>
<h3 id="列表操作命令"><a href="#列表操作命令" class="headerlink" title="列表操作命令"></a>列表操作命令</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：</p>
<ul>
<li><code>LPUSH key value1 [value2]</code>：将一个或多个值插入到列表的头部</li>
<li><code>LRANGE key start stop</code>：获取列表指定范围内的元素</li>
<li><code>RPOP key</code>：移除并获取列表最后一个元素</li>
<li><code>LLEN key</code>：获取列表长度</li>
</ul>
<h3 id="集合操作命令"><a href="#集合操作命令" class="headerlink" title="集合操作命令"></a>集合操作命令</h3><p>Redis set 是string类型的无序集合。集合成员是唯一的，集合中不能出现重复的数据，常用命令：</p>
<ul>
<li><code>SADD key member1 [member2]</code>：向集合添加一个或多个成员</li>
<li><code>SMEMBERS key</code>：返回集合中的所有成员</li>
<li><code>SCARD key</code>：获取集合的成员数</li>
<li><code>SINTER key1 [key2]</code>：返回给定所有集合的交集</li>
<li><code>SUNION key1 [key2]</code>：返回所有给定集合的并集</li>
<li><code>SREM key member1 [member2]</code>：删除集合中一个或多个成员</li>
</ul>
<h3 id="有序集合操作命令"><a href="#有序集合操作命令" class="headerlink" title="有序集合操作命令"></a>有序集合操作命令</h3><p>Redis有序集合是string类型元素的集合，且不允许有重复成员。每个元素都会关联一个double类型的分数。常用命令：</p>
<ul>
<li><code>ZADD key score1 member1 [score2 member2]</code>：向有序集合添加一个或多个成员</li>
<li><code>ZRANGE key start stop [WITHSCORES]</code>：通过索引区间返回有序集合中指定区间内的成员</li>
<li><code>ZINCRBY key increment member</code>：有序集合中对指定成员的分数加上增量 increment</li>
<li><code>ZREM key member [member ...]</code>：移除有序集合中的一个或多个成员</li>
</ul>
<h3 id="通用命令集合"><a href="#通用命令集合" class="headerlink" title="通用命令集合"></a>通用命令集合</h3><p>Redis的通用命令是不分数据类型的，都可以使用的命令：</p>
<ul>
<li><code>KEYS pattern</code>：查找所有符合给定模式（pattern）的key</li>
<li><code>EXIST key</code>：检查给定key是否存在</li>
<li><code>TYPE key</code>：返回key所存储的值的类型</li>
<li><code>DEL key</code>：该命令用于在key存在时，删除key</li>
</ul>
<h2 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h2><ol>
<li><p>导入Spring Data Redis 的maven坐标</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>配置Redis数据源</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">redis:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>编写配置类，创建RedisTemplate对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始创建redis模板对象...&quot;</span>);</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        <span class="comment">//设置 Redis 的连接工厂对象</span></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//设置 Redis 的key序列化器</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>通过RedisTemplate对象操作Redis，通过上述的配置将RedisTemplate对象自动注入，后续操作接口即可</p>
</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>全局异常处理器</title>
    <url>/2023/10/02/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h1><blockquote>
<p><b style="color:blue">悟已往之不谏，知来者之可追</b>:hash::first_quarter_moon::ant:</p>
</blockquote>
<h2 id="处理过程展示"><a href="#处理过程展示" class="headerlink" title="处理过程展示"></a>处理过程展示</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309231125992.png"
                      alt="image-20230923112514872"
                ></p>
<h2 id="问题的来由"><a href="#问题的来由" class="headerlink" title="问题的来由"></a>问题的来由</h2><p><strong>已知我有一个用户表用于存储用户的个人信息，并且设置了主键ID和username唯一</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309231133064.png"
                      alt="image-20230923113308037"
                ></p>
<p><strong>于是我接着创建一个新用户admin，系统会报错</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309231203635.png"
                      alt="image-20230923120340502"
                ></p>
<p><strong>上述错误的没有进行处理，因此当Mapper抛出Duplicate错误的时候，错误将抛出到调用mapper的service层，因为service层也没有做处理，因此错误继续向上抛至调用Service的Controller层，然后框架就会返回一个错误数据【该数据不符合我们返回值的规范，我们返回值规范是一个Result类】</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309231213299.png"
                      alt="image-20230923121310267"
                ></p>
<p><strong>为此，定义一个全局异常处理器，捕获异常，并做统一处理</strong>：创建一个类，并添加上<b style="color:blue">@RestControllerAdvice</b>注解，该注解标识这个类是一个全局异常处理器，方法上添加<b style="color:blue">@ExceptionHandler</b>注解说明捕获的异常种类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">ex</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        ex.printStackTrace();			<span class="comment">//显示异常的堆栈信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;对不起,操作失败,请联系管理员...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>@<code>ExceptionHandler</code>：通过指定注解的value属性，说明要捕获的异常 		</li>
<li>@<code>RestControllerAdvice</code>：该注解由@ControllerAdvice + @ResponseBody组成，ResponseBody会将返回值转换为JSON传递到前端</li>
</ul>
<p><strong>设置完全局异常处理器之后再次发送请求查看结果</strong>可以看到服务端捕获到异常并打印了异常的堆栈信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309231253097.png"
                      alt="image-20230923125348842"
                ></p>
<p>同时前端接收到的返回值也变成我们想要接收的数据类型</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309231255855.png"
                      alt="image-20230923125513819"
                ></p>
]]></content>
      <categories>
        <category>常见技术问题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
        <tag>spring全家桶</tag>
      </tags>
  </entry>
  <entry>
    <title>简述PageHelper的原理及使用</title>
    <url>/2023/10/03/PageHelper%E5%8E%9F%E7%90%86%E4%BD%BF%E7%94%A8%E5%8F%8A/</url>
    <content><![CDATA[<h1 id="简述PageHelper的原理及使用"><a href="#简述PageHelper的原理及使用" class="headerlink" title="简述PageHelper的原理及使用"></a>简述PageHelper的原理及使用</h1><h2 id="PageHelper原理"><a href="#PageHelper原理" class="headerlink" title="PageHelper原理"></a>PageHelper原理</h2><p><strong>PageHelper</strong>是<strong>MyBatis</strong>的通用分页插件，通过<strong>mybatis</strong>的<b style="color:red">拦截器</b>实现分页功能，<b style="color:blue">拦截sql查询请求，添加分页语句，最终实现分页查询功能。</b></p>
<p>在调用dao的Service的方法中设置分页参数：PageHelper.startPage(page,size)，分页参数会设置在<u><strong><code>ThreadLocal</code></strong></u>中然后PageHelper会在mybatis执行SQL时进行拦截，从<u><b style="color:red">ThreadLocal</b></u>取出分页参数，修改当前执行的SQL语句，添加分页SQL，最后执行添加了分页sql的sql语句实现分页查询。</p>
<h2 id="PageHelper使用"><a href="#PageHelper使用" class="headerlink" title="PageHelper使用"></a>PageHelper使用</h2><h3 id="导入pom坐标"><a href="#导入pom坐标" class="headerlink" title="导入pom坐标"></a>导入pom坐标</h3><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>版本自行选择<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p><strong>基本信息：</strong></p>
<p><strong>Path：</strong><code>/admin/employee/page</code></p>
<p><strong>Method：</strong><code>Get</code></p>
<h3 id="接口描述"><a href="#接口描述" class="headerlink" title="接口描述"></a>接口描述</h3><p><strong>Query</strong></p>
<table>
<thead>
<tr>
<th align="center">参数名称</th>
<th align="center">是否必须</th>
<th align="center">示例</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">name</td>
<td align="center">否</td>
<td align="center">张三</td>
<td align="center">姓名</td>
</tr>
<tr>
<td align="center">page</td>
<td align="center">是</td>
<td align="center">1</td>
<td align="center">页码</td>
</tr>
<tr>
<td align="center">pageSize</td>
<td align="center">是</td>
<td align="center">10</td>
<td align="center">每页记录数</td>
</tr>
</tbody></table>
<h3 id="创建DTO封装接口参数"><a href="#创建DTO封装接口参数" class="headerlink" title="创建DTO封装接口参数"></a>创建DTO封装接口参数</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该类用来封装前端传递过来的参数</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeePageQueryDTO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//员工姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//页码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> page;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每页显示记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>将所有分页查询的结果统一封装成PageResult对象。为什么？方便返回给前端</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	封装分页查询的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResult</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> total;		<span class="comment">//总记录数</span></span><br><span class="line">    <span class="keyword">private</span> List records;	<span class="comment">//当前页数据集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Controller层代码实现"><a href="#Controller层代码实现" class="headerlink" title="Controller层代码实现"></a>Controller层代码实现</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;PageResult&gt; <span class="title function_">page</span><span class="params">(EmployeePageQueryDTO employeePageQueryDTO)</span> &#123;</span><br><span class="line">	log.info(<span class="string">&quot;获取分页查询的数据:&#123;&#125;&quot;</span>,employeePageQueryDTO);</span><br><span class="line">	<span class="type">PageResult</span> <span class="variable">pageResult</span> <span class="operator">=</span> employeeService.pageQuery(employeePageQueryDTO);</span><br><span class="line">	<span class="keyword">return</span> Result.success(pageResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Service层代码实现"><a href="#Service层代码实现" class="headerlink" title="Service层代码实现"></a>Service层代码实现</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">pageQuery</span><span class="params">(EmployeePageQueryDTO employeePageQueryDTO)</span> &#123;</span><br><span class="line">	<span class="comment">//开始分页查询，将分页参数传递到ThreadLocal中</span></span><br><span class="line">	PageHelper.startPage(employeePageQueryDTO.getPage(),employeePageQueryDTO.getPageSize());</span><br><span class="line">    <span class="comment">//将Mapper层查询到的数据封装在Page中，Page本质上也是一个List</span></span><br><span class="line">	Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);</span><br><span class="line">    <span class="comment">//获取总记录数和查询的记录</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> page.getTotal();	<span class="comment">//获取记录总数</span></span><br><span class="line">	List&lt;Employee&gt; result = page.getResult();	<span class="comment">//获取所有记录</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageResult</span>(total,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="DAO层代码实现"><a href="#DAO层代码实现" class="headerlink" title="DAO层代码实现"></a>DAO层代码实现</h3><p><strong>因为涉及到模糊查询所以dao层的sql语句写在xml文件中会更加灵活</strong></p>
<p><strong>在EmployeeMapper.java文件中代码实现如下：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Page&lt;Employee&gt; <span class="title function_">pageQuery</span><span class="params">(EmployeePageQueryDTO employeePageQueryDTO)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>在EmployeeMapper.xml文件中代码实现如下：</strong></p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;pageQuery&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sky.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">	select * from employee</span><br><span class="line">	<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">			and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">	order by create_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><strong>首先看到初始的数据表中有如下记录</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310031558189.png"
                      alt="image-20231003140210891"
                ></p>
<p><strong>在不添加name的查询条件的时候，测试接口确实成功实现查询到了正确的数据，但是可以看到返回结果中时间类型的数据返回格式是不适合前端展示的</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310031559077.png"
                      alt="image-20231003140635158"
                ></p>
<h4>解决方式：</h4>

<ul>
<li><p><strong>方式一</strong>：在属性上加入注解，对日期进行格式化</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime updateTime;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>方式二</strong>：在WebMvcConfiguration 中拓展 SpringMVC 的消息转换器，统一对日期类型进行格式化处理</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩展mvc框架的消息转换器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> converters</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">	log.info(<span class="string">&quot;扩展消息转换器...&quot;</span>);</span><br><span class="line">	<span class="comment">//创建一个消息转换器对象</span></span><br><span class="line">	<span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">messageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">	<span class="comment">//需要为消息转换器，创建一个对象转换器，对象转换器可以将Java对象序列化为JSON数据</span></span><br><span class="line">	messageConverter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line">	<span class="comment">//将自己的消息转换器加入到容器中</span></span><br><span class="line">	converters.add(<span class="number">0</span>,messageConverter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>根据上述的两种方式选择自己喜欢的方式即可，不过大多数情况下建议使用第二种方式，但是使用第二种方式的时候对象转换器又是什么呢？下面给出一个Jackson的对象转换器作为参考</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象</span></span><br><span class="line"><span class="comment"> * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]</span></span><br><span class="line"><span class="comment"> * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonObjectMapper</span> <span class="keyword">extends</span> <span class="title class_">ObjectMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line">    <span class="comment">//public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;HH:mm:ss&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JacksonObjectMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">//收到未知属性时不报异常</span></span><br><span class="line">        <span class="built_in">this</span>.configure(FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化时，属性不存在的兼容处理</span></span><br><span class="line">        <span class="built_in">this</span>.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleModule</span> <span class="variable">simpleModule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleModule</span>()</span><br><span class="line">                .addDeserializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))</span><br><span class="line">                .addSerializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addSerializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addSerializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册功能模块 例如，可以添加自定义序列化器和反序列化器</span></span><br><span class="line">        <span class="built_in">this</span>.registerModule(simpleModule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>有了上述的知识基础，创建一个消息转换器并使用</strong>，然后重新启动服务进行测试</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310031559762.png"
                      alt="image-20231003141157673"
                ></p>
<p>可以看到此时前端接收到的数据就是比较适合使用的时间格式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310031559367.png"
                      alt="image-20231003141616468"
                ></p>
]]></content>
      <categories>
        <category>常见技术问题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring整合Mybatis/Junit</title>
    <url>/2023/09/18/Spring%E6%95%B4%E5%90%88MyBatis_Junit/</url>
    <content><![CDATA[<h1 id="Spring整合Mybatis-Junit"><a href="#Spring整合Mybatis-Junit" class="headerlink" title="Spring整合Mybatis&#x2F;Junit"></a>Spring整合Mybatis&#x2F;Junit</h1><ul>
<li><h4 id="原生Mybatis的XML配置文件"><a href="#原生Mybatis的XML配置文件" class="headerlink" title="原生Mybatis的XML配置文件"></a><strong>原生Mybatis的XML配置文件</strong></h4></li>
</ul>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.domain&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.Driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--加载sql的映射文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h2><ol>
<li><h4 id="第一步：添加对应的坐标"><a href="#第一步：添加对应的坐标" class="headerlink" title="第一步：添加对应的坐标"></a>第一步：<strong>添加对应的坐标</strong></h4><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring的坐标【Spring技术的核心】 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- druid数据连接池 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- MyBatis的坐标 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- mysql的坐标 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Spring操作数据库专用的包坐标 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Spring整合Mybatis的包坐标【版本号要与mybatis版本对应】 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><h4 id="第二步：创建外部配置文件【jdbc-properties】"><a href="#第二步：创建外部配置文件【jdbc-properties】" class="headerlink" title="第二步：创建外部配置文件【jdbc.properties】"></a>第二步：<strong>创建外部配置文件【jdbc.properties】</strong></h4><div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbcDriver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc.mysql://127.0.0.1:3306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><h4 id="第三步：创建数据源配置类【JdbcConfig-java】"><a href="#第三步：创建数据源配置类【JdbcConfig-java】" class="headerlink" title="第三步：创建数据源配置类【JdbcConfig.java】"></a>第三步：<strong>创建数据源配置类【JdbcConfig.java】</strong></h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(username);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><h4 id="第四步：创建配置类【SpringConfig-java】"><a href="#第四步：创建配置类【SpringConfig-java】" class="headerlink" title="第四步：创建配置类【SpringConfig.java】"></a>第四步：<strong>创建配置类【SpringConfig.java】</strong></h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>						<span class="comment">//声明为Spring的配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span>					<span class="comment">//bean的扫描</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span>		<span class="comment">//扫描外部配置文件</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)</span>				<span class="comment">//第三方的bean管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span>&#123;&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><h4 id="第五步：创建一个Mybatis的配置类用于管理第三方-Mybatis-的bean【MybatisConfig-java】代替原生Mybatis的xml配置文件"><a href="#第五步：创建一个Mybatis的配置类用于管理第三方-Mybatis-的bean【MybatisConfig-java】代替原生Mybatis的xml配置文件" class="headerlink" title="第五步：创建一个Mybatis的配置类用于管理第三方(Mybatis)的bean【MybatisConfig.java】代替原生Mybatis的xml配置文件"></a>第五步：<strong>创建一个Mybatis的配置类用于管理第三方(Mybatis)的bean【MybatisConfig.java】代替原生Mybatis的xml配置文件</strong></h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202308021214406.png"
                      alt="image-20230802121432063"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202308021215004.png"
                      alt="image-20230802121512784"
                ></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domian&quot;</span>);<span class="comment">//原生XML配置的&lt;typeAliases&gt;标签</span></span><br><span class="line">        ssfb.setDataSource(dataSource);<span class="comment">//原生XML配置的&lt;dataSource&gt;标签</span></span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfiguree</span><span class="params">()</span>&#123;	<span class="comment">//原生XML配置的mapper映射标签</span></span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h2><ol>
<li><h4 id="添加对应的坐标"><a href="#添加对应的坐标" class="headerlink" title="添加对应的坐标"></a>添加对应的坐标</h4><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><h4 id="创建测试类【MyTestClass-java】"><a href="#创建测试类【MyTestClass-java】" class="headerlink" title="创建测试类【MyTestClass.java】"></a>创建测试类【MyTestClass.java】</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span>			<span class="comment">//Spring整合JUnit专用的类加载器</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span>		<span class="comment">//指定Spring上下文配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> MyService myservice;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myTestOne</span><span class="params">()</span>&#123; <span class="comment">/*函数实现*/</span>  	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
        <tag>spring全家桶</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传下载</title>
    <url>/2023/10/04/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="一、文件上传介绍"><a href="#一、文件上传介绍" class="headerlink" title="一、文件上传介绍"></a><span style="color:purple">一、文件上传介绍</span></h2><p>文件上传，也称为upload，是将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或者下载的过程</p>
<p>文件上传时，对页面的form表单有如下要求：</p>
<ul>
<li><code>method=&quot;post&quot;</code> 							        采用post方式提交数据</li>
<li><code>enctype=&quot;multipart/form-data&quot; </code>   采用multipart格式上传文件</li>
<li><code>type=&quot;file&quot;</code>                                       使用input的file控件上传</li>
</ul>
<p><strong>举例</strong></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/common/upload&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;myFile&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></div>



<p>服务端要接收客户端页面上传的文件，通常会使用Apache的两个插件</p>
<ul>
<li><code>commons-fileupload</code></li>
<li><code>commons-io</code></li>
</ul>
<p>Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中声明一个<code>MultipartFile</code>类型的参数即可接收上传的文件，例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 文件上传</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span>&#123;</span><br><span class="line">	System.out.println(file);</span><br><span class="line">	<span class="keyword">return</span> Result.success(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="二、文件下载介绍"><a href="#二、文件下载介绍" class="headerlink" title="二、文件下载介绍"></a><span style="color:green">二、文件下载介绍</span></h2><p>文件下载，也称为download，是指将文件从服务器传输到本地计算机的过程</p>
<p>通过浏览器进行文件下载，通常有两种表现形式：</p>
<ul>
<li>以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录</li>
<li>直接在浏览器中打开</li>
</ul>
<p>通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程</p>
<h2 id="三、文件上传接收代码实现"><a href="#三、文件上传接收代码实现" class="headerlink" title="三、文件上传接收代码实现"></a><span style="color:red">三、文件上传接收代码实现</span></h2><h3 id="前端数据方法代码"><a href="#前端数据方法代码" class="headerlink" title="前端数据方法代码"></a>前端数据方法代码</h3><ul>
<li>此处调用axios向接口：<code>http://localhost:3000/common/upload</code>发送了表单数据设置表头header为<code>Content-type:multipar/form-data</code>，数据包含：<ol>
<li><code>username</code>：字符串类型</li>
<li><code>gender</code>：字符串类型</li>
<li><code>introduction</code>：字符串类型</li>
<li><code>avatar</code>：字符串类型</li>
<li><code>file</code>：文件类型</li>
</ol>
</li>
</ul>
<center class="half">    
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309150932591.png"
                      alt="image-20230913170017182" width="330" height="270px"  style="border:solid 2px orange"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309150933147.png"
                      alt="image-20230913170130306" width="600" height="270px"  style="border:solid 2px orange"
                >
</center>


<ul>
<li>打开调试工具查看发送的表单数据，观察发送数据的<code>name</code></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309150933419.png"
                      width="500px" style="border:solid 2px blue"
                >

<h3 id="后端接口代码实现"><a href="#后端接口代码实现" class="headerlink" title="后端接口代码实现"></a>后端接口代码实现</h3><ul>
<li><strong><span style="color:blue">第一种写法：</span></strong></li>
</ul>
<p>接口的参数对应表单数据的各项name，文件类型使用<code>MultipartFile</code>接收，若接口参数名与前端发送数据的name一致的时候可以不使用注解<code>@RequestParam</code>对应</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>						<span class="comment">//打印日志</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload</span><span class="params">( <span class="meta">@RequestParam(&quot;username&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(&quot;gender&quot;)</span> Integer gender,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(&quot;introduction&quot;)</span> String introduction,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(&quot;avatar&quot;)</span> String avatar,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(&quot;file&quot;)</span>MultipartFile file)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;更新用户名:&#123;&#125;&quot;</span>,username);</span><br><span class="line">        log.info(<span class="string">&quot;更新性别:&#123;&#125;&quot;</span>,gender == <span class="number">1</span>?<span class="string">&#x27;男&#x27;</span>:gender==<span class="number">0</span>?<span class="string">&quot;女&quot;</span>:<span class="string">&quot;保密&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;用户简介:&#123;&#125;&quot;</span>,introduction);</span><br><span class="line">        log.info(<span class="string">&quot;头像地址:&#123;&#125;&quot;</span>,avatar);</span><br><span class="line">        log.info(<span class="string">&quot;接收到文件:&#123;&#125;&quot;</span>,file.toString());</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;接收到上传的数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><span style="color:blue">第二种写法：</span></strong></li>
</ul>
<p>考虑到需要接收的表单数据比较到，直接将所有参数写在接口上会显得代码比较繁琐，因此创建一个DTO来封装数据</p>
<ol>
<li><p>创建UploadDTO类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span>					<span class="comment">//对所有的数据创建getter和setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>		<span class="comment">//无参构造函数</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span>		<span class="comment">//有参构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadDTO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> gender;</span><br><span class="line">    <span class="keyword">private</span> String introduction;</span><br><span class="line">    <span class="keyword">private</span> String avatar;</span><br><span class="line">    <span class="keyword">private</span> MultipartFile file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用DTO接收参数</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload</span><span class="params">(UploadDTO user)</span>&#123;</span><br><span class="line">	log.info(user.getFile().toString());</span><br><span class="line">	<span class="keyword">return</span> Result.success(<span class="string">&quot;接收到上传的数据&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="四、将上传的文件保存在本地"><a href="#四、将上传的文件保存在本地" class="headerlink" title="四、将上传的文件保存在本地"></a>四、将上传的文件保存在本地</h2><ol>
<li><p>在配置文件中配置本地的路径，此处我的配置文件为<code>application.yml</code>，设置了基本路径为<code>D:\\Desktop</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309151210089.png"
                      alt="image-20230915121019943"
                ></p>
</li>
<li><p>使用注解<code>@Value</code>接收配置文件的数据，并使用<code>UUID生存随机种子(保证文件名唯一)</code>，将上传文件保存到本地</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mystudy.basePath&#125;&quot;)</span>		<span class="comment">//@Value接收配置项数据</span></span><br><span class="line">    <span class="keyword">private</span> String basePath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span>		<span class="comment">//此处DTO对象描述看上文</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload</span><span class="params">(UploadDTO user)</span>&#123;</span><br><span class="line">        <span class="comment">//file是一个零时文件，需要转存到指定位置，否则本次请求完成后文件会删除</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取源文件的文件名字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> user.getFile().getOriginalFilename();</span><br><span class="line">            <span class="comment">//获取源文件的后缀</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">            <span class="comment">//根据UUID生成的随机数加上源文件的后缀名生成新的文件名[唯一不重复]</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">newName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extension;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//创建一个目录对象</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(basePath);</span><br><span class="line">            <span class="comment">//判断当前目录是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(!dir.exists()) dir.mkdirs();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将临时文件转存到指定位置</span></span><br><span class="line">            user.getFile().transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(basePath+ newName));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;文件上传失败：&#123;&#125;&quot;</span>,e);</span><br><span class="line">            <span class="keyword">return</span> Result.error(<span class="string">&quot;文件上传失败...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;成功接收上传数据&quot;</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="五、配置文件上传选项"><a href="#五、配置文件上传选项" class="headerlink" title="五、配置文件上传选项"></a>五、配置文件上传选项</h2><ul>
<li>在SpringBoot中，文件上传，默认单个文件允许最大大小为<code>1M</code>.如果需要上传大文件，则进行如下配置</li>
</ul>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开application.yml配置文件</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">multipart:</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">10MB</span>				<span class="comment">#配置单个文件最大上传大小</span></span><br><span class="line">      <span class="attr">max-request-size:</span> <span class="string">100MB</span>			<span class="comment">#配置单个请求最大上传大小(一次请求可以上传多个文件)</span></span><br></pre></td></tr></table></figure></div>



<h2 id="六、文件上传阿里云OSS"><a href="#六、文件上传阿里云OSS" class="headerlink" title="六、文件上传阿里云OSS"></a><span style="color:purple">六、文件上传阿里云OSS</span></h2><h3 id="第一步：导入依赖"><a href="#第一步：导入依赖" class="headerlink" title="第一步：导入依赖"></a>第一步：导入依赖</h3><blockquote>
<p>官方文档地址：<a class="link"   href="https://help.aliyun.com/zh/oss/developer-reference/java-installation?spm=a2c4g.11186623.0.0.13dc3ba3geaLZ3"  style="color:red;font-weight:800">在这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<ul>
<li>首先导入阿里云的依赖【Java 9版本以上】</li>
</ul>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.15.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- no more than 2.3.3--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="第二步：创建数据配置类"><a href="#第二步：创建数据配置类" class="headerlink" title="第二步：创建数据配置类"></a>第二步：创建数据配置类</h3><ol>
<li><p><strong>现在<code>application.yml</code>文件中写入数据</strong></p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aliyun:</span></span><br><span class="line">  <span class="attr">oss:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">桶子归属地域</span></span><br><span class="line">    <span class="attr">bucketName:</span> <span class="string">桶子的名字</span></span><br><span class="line">    <span class="attr">accessKeyId:</span> <span class="string">自己OSS桶子的accessKeyId</span></span><br><span class="line">    <span class="attr">accessKeySecret:</span> <span class="string">自己桶子的accessKeySecret</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>创建配置类</strong><code>AliOssProperties</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span>					<span class="comment">//为类添加getter/setter</span></span><br><span class="line"><span class="meta">@Component</span>				<span class="comment">//交给IOC管理</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span>			<span class="comment">//将上述前缀为aliyun.oss配置数据匹配</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOssProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>创建实现对象</strong><code>AliOssUtil</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOssUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="type">byte</span>[] bytes,String objectName)</span> &#123;</span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PutObjectRequest</span> <span class="variable">putObjectRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PutObjectRequest</span>(bucketName, objectName, <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">            <span class="type">PutObjectResult</span> <span class="variable">putObjectResult</span> <span class="operator">=</span> ossClient.putObject(putObjectRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an OSSException, which means your request made it to OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;but was rejected with an error response for some reason.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + oe.getErrorMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Code:&quot;</span> + oe.getErrorCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Request ID:&quot;</span> + oe.getRequestId());</span><br><span class="line">            System.out.println(<span class="string">&quot;Host ID:&quot;</span> + oe.getHostId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an ClientException, which means the client encountered &quot;</span></span><br><span class="line">                    + <span class="string">&quot;a serious internal problem while trying to communicate with OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;such as not being able to access the network.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + ce.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ossClient != <span class="literal">null</span>) &#123;</span><br><span class="line">                ossClient.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//文件访问路径规则 https://BucketName.Endpoint/ObjectName</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;https://&quot;</span>);</span><br><span class="line">        stringBuilder</span><br><span class="line">                .append(bucketName)</span><br><span class="line">                .append(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                .append(endpoint)</span><br><span class="line">                .append(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .append(objectName);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;文件上传到:&#123;&#125;&quot;</span>, stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>创建实现对象的”工厂”</strong><code>OSSConfiguration</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OSSConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> AliOssUtil <span class="title function_">aliOssUtil</span><span class="params">(AliOssProperties aliOssProperties)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始创建阿里云上传工具类对象：&#123;&#125;&quot;</span>,aliOssProperties);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AliOssUtil</span>(aliOssProperties.getEndpoint(),</span><br><span class="line">                aliOssProperties.getAccessKeyId(),</span><br><span class="line">                aliOssProperties.getAccessKeySecret(),</span><br><span class="line">                aliOssProperties.getBucketName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="第三步：后端接口代码实现"><a href="#第三步：后端接口代码实现" class="headerlink" title="第三步：后端接口代码实现"></a>第三步：后端接口代码实现</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行文件的云上传【阿里云OSS存储】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span>				<span class="comment">//将OSS配置类导入</span></span><br><span class="line">    <span class="keyword">private</span> AliOssUtil aliOssUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload_OSS</span><span class="params">(UploadDTO user)</span>&#123;<span class="comment">//此处DTO看上文，上文封装了</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//原始的文件名字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> user.getFile().getOriginalFilename();</span><br><span class="line">            <span class="comment">//截取文件名的后缀</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">            <span class="comment">//构造新的文件名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">newName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extension;</span><br><span class="line">            <span class="comment">//获取返回的文件请求路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> aliOssUtil.upload(user.getFile().getBytes(), newName);</span><br><span class="line">            <span class="keyword">return</span> Result.success(filePath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;文件上传失败：&#123;&#125;&quot;</span>,e);</span><br><span class="line">            <span class="keyword">return</span> Result.error(<span class="string">&quot;上传文件失败...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>常见技术问题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>开发规范(Swagger) + 接口文档</title>
    <url>/2023/10/06/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83(Swagger)/</url>
    <content><![CDATA[<h1 id="开发规范-Swagger-接口文档"><a href="#开发规范-Swagger-接口文档" class="headerlink" title="开发规范(Swagger) + 接口文档"></a>开发规范(Swagger) + 接口文档</h1><blockquote>
<p>归去来兮辞:japan::japanese_goblin::ice_cream:</p>
</blockquote>
<h2 id="前后端开发流程"><a href="#前后端开发流程" class="headerlink" title="前后端开发流程"></a>前后端开发流程</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309271337049.png"
                      alt="image-20230927133706958"
                ></p>
<hr>

<h2 id="Swagger介绍"><a href="#Swagger介绍" class="headerlink" title="Swagger介绍"></a>Swagger介绍</h2><p>使用Swagger只需要按照它的规范去定义接口以及接口相关的信息，就可以做到生成接口文档，以<span style="color:red">及在线接口调试</span>页面</p>
<p>官网：<a class="link"   href="https://swagger.io/" >https://swagger.io/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><b style="color:blue">Knife4j</b>是Java MVC框架集成Swagger生成Api文档的增强解决方案</p>
<hr>

<h2 id="Swagger使用方式"><a href="#Swagger使用方式" class="headerlink" title="Swagger使用方式"></a>Swagger使用方式</h2><p><strong>在这里引入一点小知识</strong></p>
<p><code>WebMvcConfigurer</code>和<code> WebMvcConfigurationSupport</code> 都是用来配置 <code>Spring MVC</code>的接口，但是它们有一些不同：</p>
<ol>
<li><code>WebMvcConfigurer </code>是一个简单的接口，提供了一组回调方法，用于配置 Spring MVC。您可以实现这个接口并覆盖它的回调方法来配置 Spring MVC。</li>
<li><code>WebMvcConfigurationSupport </code>是一个特殊的抽象类，实现了 WebMvcConfigurer 接口，并且提供了一组默认实现。您可以扩展这个类并覆盖它的方法来配置 Spring MVC。</li>
</ol>
<p><strong>总的来说，如果只需要实现一些简单的配置，可以使用 WebMvcConfigurer；如果需要实现更复杂的配置，则可以扩展 WebMvcConfigurationSupport 类。</strong></p>
<p><strong>下面是我原来的SpringMVC配置类</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309271942376.png"
                      alt="image-20230927194154159" style="zoom: 80%;" 
                >

<p>因为需要加入Swagger所以将<strong>implements WebMVCConfigurer</strong>转为<strong>extend WebMvcConfigurationSupport</strong>并继续下述操作</p>
<ol>
<li><p><strong>导入knife4j 的maven坐标</strong></p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2. **在配置类中加入 Knife4j 相关配置**</span><br><span class="line"></span><br><span class="line">   ~~~java</span><br><span class="line">   @Bean</span><br><span class="line">   public Docket docket() &#123;</span><br><span class="line">   	ApiInfo apiInfo = new ApiInfoBuilder()</span><br><span class="line">   		.title(&quot;接口文档标题&quot;)</span><br><span class="line">   		.version(&quot;2.0&quot;)</span><br><span class="line">   		.description(&quot;接口文档描述&quot;)</span><br><span class="line">   		.build();</span><br><span class="line">   	Docket docket = new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">   		.apiInfo(apiInfo)</span><br><span class="line">   		.select()</span><br><span class="line">           //指定生成接口需要扫描的包</span><br><span class="line">   		.apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller&quot;))</span><br><span class="line">   		.paths(PathSelectors.any())</span><br><span class="line">   		.build();</span><br><span class="line">   	return docket;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>设置静态资源映射，否则接口文档页面无法访问</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置静态资源映射</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">//doc.html就是我们接口文档的访问路径 </span></span><br><span class="line">    registry.addResourceHandler(<span class="string">&quot;/doc.html&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">    registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<hr>

<p><strong>配置完之后的SpringMVC配置类应该是这样子的</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309271947173.png"
                      alt="image-20230927194748964"
                ></p>
<p><strong>启动项目测试是否能打开接口文档</strong>，可以看到接口文档配置成功启动，并且知道SpringBoot项目运行在3000端口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309272000975.png"
                      alt="image-20230927200044657"
                ></p>
<p>随后打开文档页面，打开浏览器<code>http://localhost:3000/doc.html</code>，可以看到文档页面成功生成啦…</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309272002932.png"
                      alt="image-20230927200225860"
                ></p>
<blockquote>
<p><strong>注意事项</strong>：</p>
<p>若是打不开页面，检查是否因为</p>
<ol>
<li>过滤器导致页面无法访问</li>
<li>路由重定向？【可能出现，概率小，几乎不存在】</li>
<li>knife4j没有配置好</li>
</ol>
</blockquote>
<h2 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a>Swagger常用注解</h2><ul>
<li><strong>通过注解可以控制生成的接口文档，使接口文档拥有更好的可读性，常用注解如下：</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">注解</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>@Api</code></td>
<td align="center">用在类上，例如Controller，表示对类的说明</td>
</tr>
<tr>
<td align="center"><code>@ApiModel</code></td>
<td align="center">用在类上，例如entity、DTO、VO</td>
</tr>
<tr>
<td align="center"><code>@ApiModelProperty</code></td>
<td align="center">用在属性上，描述属性信息</td>
</tr>
<tr>
<td align="center"><code>ApiOperation</code></td>
<td align="center">用在方法上，例如Controller的方法，说明方法的用途、作用</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<p><b style="color:blue">我对如下类、方法、数据模型、模型元数据进行了Api注解</b></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309272049294.png"
                      alt="image-20230927204609455"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309272049750.png"
                      alt="image-20230927204559391"
                ></p>
<p><strong>启动项目，查看接口文档的变化，首先查看不添加注释的API文档</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309272340913.png"
                      alt="image-20230927234043798" style="zoom: 50%;" 
                >

<p><strong>添加注解后的生成的API文档更容易阅读</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309272340640.png"
                      alt="image-20230927234052570" style="zoom:50%;" 
                >
]]></content>
      <categories>
        <category>常见技术问题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>登录认证《JWT+Filter+Interceptor》</title>
    <url>/2023/10/05/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E3%80%8AJWT+Filter+Interceptor%E3%80%8B/</url>
    <content><![CDATA[<h1 id="登录认证《JWT-Filter-Interceptor》"><a href="#登录认证《JWT-Filter-Interceptor》" class="headerlink" title="登录认证《JWT+Filter+Interceptor》"></a>登录认证《JWT+Filter+Interceptor》</h1><blockquote>
<p><b style="color:green;width:100%;text-align:center" >$\int_{birth}^{death}卷dt &#x3D; life$</b>:1st_place_medal: :hamburger::happy::broken_heart:</p>
</blockquote>
<h2 id="一、会话技术"><a href="#一、会话技术" class="headerlink" title="一、会话技术"></a>一、会话技术</h2><ul>
<li><strong>会话</strong>：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含<span style="color:red">多次</span>请求和响应</li>
<li><strong>会话跟踪</strong>：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自同一浏览器，以便在同一次会话的多次请求间<span style="color:red">共享数据</span></li>
<li><strong>会话跟踪方案</strong>：<ol>
<li><strong>客户端会话跟踪技术</strong>：Cookie</li>
<li><strong>服务端会话跟踪技术</strong>：Session</li>
<li><strong>令牌技术</strong></li>
</ol>
</li>
</ul>
<h2 id="二、会话跟踪方案对比"><a href="#二、会话跟踪方案对比" class="headerlink" title="二、会话跟踪方案对比"></a>二、会话跟踪方案对比</h2><h3 id="2-1、方案一：Cookie【传统】"><a href="#2-1、方案一：Cookie【传统】" class="headerlink" title="2.1、方案一：Cookie【传统】"></a>2.1、方案一：Cookie【传统】</h3><p>Cookie是保存在<b style="color:red">浏览器本地</b>的，用户向后端发起登录请求之后，后端服务器会<strong>自动</strong>返回一个Cookie值给浏览器，同时浏览器将该Cookie值保存在浏览器本地中，之后的每一次浏览器请求，都会<strong>自动</strong>带上这个Cookie值，后端根据Cookie值判断该浏览器是否登陆过。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309212132131.png"
                      alt="image-20230921213226025"
                ></p>
<p><strong>优点</strong>：HTTP协议中支持的技术</p>
<p><strong>缺点：</strong></p>
<ol>
<li>移动端APP无法使用Cookie</li>
<li>不安全，用户可以自己禁用Cookie</li>
<li>Cookie不能跨域【跨域是什么？自己去了解】</li>
</ol>
<h4 id="代码实现：操作Cookie"><a href="#代码实现：操作Cookie" class="headerlink" title="代码实现：操作Cookie"></a>代码实现：操作Cookie</h4><p>下面实现操作Cookie的代码，通过访问：</p>
<ol>
<li><code>http://localhost:3000/study/setcookie</code>：访问该地址，服务器会向前端发送一个Cookie</li>
<li><code>http://localhost:3000/study/getcookie</code>：访问改地址，服务器获取前端传递的Cookie</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/study&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudyController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问地址：http://localhost:3000/study/setcookie 设置Cookie值在响应response中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/setcookie&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">setCookie</span><span class="params">(HttpServletResponse response)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取设置Cookie的请求&quot;</span>);</span><br><span class="line">        response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;login_username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从请求request中获取Cookie值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getcookie&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getCookie</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取得到Cookie的请求&quot;</span>);</span><br><span class="line">        Cookie[] cookies = request.getCookies();    <span class="comment">//获取到所有Cookie</span></span><br><span class="line">        <span class="keyword">for</span>(Cookie cookie : cookies)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cookie.getName().equals(<span class="string">&quot;login_username&quot;</span>))&#123; <span class="comment">//输出name为login_username的Cookie</span></span><br><span class="line">                System.out.println(<span class="string">&quot;login_username: &quot;</span> + cookie.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="设置Cookie效果图展示"><a href="#设置Cookie效果图展示" class="headerlink" title="设置Cookie效果图展示"></a>设置Cookie效果图展示</h4><p><strong>首先F12打开浏览器的调试工具点击NetWork选项查看发送的请求信息</strong></p>
<p>可以看到请求了<code>http://localhost:3000/study/setcookie</code>路径之后，服务器向前端的响应<strong>Response</strong>中包含<strong>Set-Cookie</strong>一项</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309212152416.png"
                      alt="image-20230921215243363" style="zoom:80%;" 
                >

<p>然后我们继续点击<code>Application</code>一项可以看到我们设置的Cookie值成功保存在浏览器本地存储</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309212157905.png"
                      alt="image-20230921215746870"
                ></p>
<h4 id="获取Cookie效果图展示"><a href="#获取Cookie效果图展示" class="headerlink" title="获取Cookie效果图展示"></a>获取Cookie效果图展示</h4><p>继上述设置Cookie操作之后，继续访问页面<code>http://localhost:3000/study/getcookie</code>，同样的，打开调试工具，并点击NetWork选项查看<strong>请求request</strong>中的Cookie一栏，确实是我们刚才设置的cookie</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309212203416.png"
                      alt="image-20230921220327371"
                ></p>
<p><strong>查看我们的后端的显示，确实得到了前端向后端请求中的cookie值</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309212206687.png"
                      alt="image-20230921220603439"
                ></p>
<h3 id="2-2、方案二：Session【传统】"><a href="#2-2、方案二：Session【传统】" class="headerlink" title="2.2、方案二：Session【传统】"></a>2.2、方案二：Session【传统】</h3><p>Session是保存在服务器中的，Session的底层是基于Cookie来实现的。</p>
<p>浏览器第一次向服务器发送请求的时候，服务器会自动创建<b style="color:red">会话对象Session</b>，每一个会话对象都有一个ID，称之为Session的ID，接下来服务器向浏览器响应数据的时候会<strong>将Session的ID通过Cookie响应给浏览器</strong>，浏览器接收到这个响应数据之后会自动<strong>将存有SessionId的cookie保存在浏览器本地</strong>，然后后续的请求中，浏览器会<strong>将该Cookie的值携带到服务端</strong>，服务器<strong>拿到这个前端传来的cookie</strong>后，会从全部请求对象中<strong>找到当前请求对应的会话对象</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309212316101.png"
                      alt="image-20230921231659057"
                ></p>
<p><strong>优点：</strong>存储在服务器，安全</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>服务器级群环境下无法直接使用Session</li>
<li>Cookie的缺点【Session底层实现为Cookie】</li>
</ol>
<h4 id="代码实现：操作Session"><a href="#代码实现：操作Session" class="headerlink" title="代码实现：操作Session"></a>代码实现：操作Session</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/study&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudyController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Session对象,hashCode可以理解为SessionId每一个Session对象有唯一的hashCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/setsession&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">setSession</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;HttpSession-setSession:&#123;&#125;&quot;</span>,session.hashCode());</span><br><span class="line">        session.setAttribute(<span class="string">&quot;loginUser&quot;</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从HttpSession中获取Session，并获取其hashCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getsession&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getSession</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        log.info(<span class="string">&quot;HttpSession-getSession:&#123;&#125;&quot;</span>,session.hashCode());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">loginUser</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;loginUser:&#123;&#125;&quot;</span>,loginUser);</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="设置Session的效果图"><a href="#设置Session的效果图" class="headerlink" title="设置Session的效果图"></a>设置Session的效果图</h4><p><strong>首先F12打开浏览器的调试工具点击NetWork选项查看发送的请求信息</strong></p>
<p>可以看到请求了<code>http://localhost:3000/study/setsession</code>路径之后，服务器向前端的响应<strong>Response</strong>中包含<strong>Set-Cookie</strong>一项，并且保存的值是Session的ID</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309212304566.png"
                      alt="image-20230921230445503"
                ></p>
<p>然后我们继续点击<code>Application</code>一项可以看到我们设置的session值成功保存在浏览器本地存储</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309212306821.png"
                      alt="image-20230921230617782"
                ></p>
<h4 id="获取Session效果图展示"><a href="#获取Session效果图展示" class="headerlink" title="获取Session效果图展示"></a>获取Session效果图展示</h4><p>继上述设置session操作之后，继续访问页面<code>http://localhost:3000/study/getsession</code>，同样的，打开调试工具，并点击NetWork选项查看<strong>请求request</strong>中的Cookie一栏，确实是我们刚才设置的session</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309212309411.png"
                      alt="image-20230921230938366"
                ></p>
<p><strong>查看我们的后端的显示，看到setsession和getsession两次请求输出的ID值相同，表明确实是同一个Session对象</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309212311778.png"
                      alt="image-20230921231145486"
                ></p>
<h3 id="2-3、方案三：令牌JWT【主流】"><a href="#2-3、方案三：令牌JWT【主流】" class="headerlink" title="2.3、方案三：令牌JWT【主流】"></a>2.3、方案三：令牌JWT【主流】</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309212335252.png"
                      alt="image-20230921233534209"
                ></p>
<p><strong>优点</strong>：</p>
<ol>
<li>支持PC端、移动端</li>
<li>解决集群环境下的认证问题</li>
<li>减轻服务器端存储压力</li>
</ol>
<p><strong>缺点</strong>：需要自己实现</p>
<h4 id="了解JWT"><a href="#了解JWT" class="headerlink" title="了解JWT"></a>了解JWT</h4><ul>
<li><strong>全称</strong>：<a href="https://jwt.io/"><b style="color:red">J</b>SON <b style="color:red">W</b>eb <b style="color:red">T</b>oken</a></li>
<li>定义了一种简洁、自包含的格式，用于在通信双方以JSON数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的</li>
<li>组成：<ol>
<li><strong>第一部分</strong>：<strong>Header</strong>(头)，记录令牌类型、签名算法等。例如：{“alg”:”HS256”,”type”:”JWT”}</li>
<li><strong>第二部分</strong>：<strong>Payload</strong>(有效载荷)，携带一些自定义信息、默认信息等。例如：{“id”:”1”,”username”:”Tom”}</li>
<li><strong>第三部分</strong>：<strong>Signature</strong>(签名)，防止Token被串改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来</li>
</ol>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309212345412.png"
                      alt="image-20230921234520362"
                ></p>
<blockquote>
<p><strong>细节：</strong>JWT组成的前两部分<b style="color:green">[Payload、Signature]</b>是<b style="color:red">JSON数据</b>通过<b style="color:blue">Base64</b>编码组成，第三部分的数字签名<strong>融入前两部分的内容并加入秘钥通过特定算法计算出来</strong>的，所以核心就是第三部分的签名，该签名唯一标识我们的令牌</p>
<p>【Base64：是一种基于64个可打印字符（A-Z a-z 0-9 + &#x2F;）来表示二进制数据的编码方式】</p>
</blockquote>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><strong>典型使用场景</strong>：登录认证。<ol>
<li>登录成功后，生成令牌【令牌生成：登录成功后生成JWT令牌，并返回给前端】</li>
<li>后续每个请求，都要携带JWT令牌，系统在每次请求处理之前，先校验令牌，通过后，在处理【在请求到达服务端后，对令牌进行统一拦截，校验】</li>
</ol>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309212350034.png"
                      alt="image-20230921235042977"
                ></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>要使用JWT技术，首先导入JWT的依赖</li>
</ul>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 style="color:blue">生成JWT</h4>

<p><strong>生成JWT需要使用Jwts的三个方法</strong></p>
<ul>
<li><code>signWith</code>：设置签名算法以及秘钥【jwt组成三部分的<b style="color:green">第一部分</b>】</li>
<li><code>setClaims</code>：设置载荷数据【jwt组成三部分的<b style="color:green">第二部分</b>】</li>
<li><code>setExpiration</code>：设置过期时间$(参数以毫秒为单位)$</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">genJwt</span><span class="params">()</span>&#123;</span><br><span class="line">	Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();		<span class="comment">//载荷部分接收一个Map作为参数</span></span><br><span class="line">	claims.put(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">	claims.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">		.signWith(SignatureAlgorithm.HS256,<span class="string">&quot;token&quot;</span>)     	<span class="comment">//设置签名算法</span></span><br><span class="line">		.setClaims(claims)                                  <span class="comment">//设置载荷数据</span></span><br><span class="line">		.setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()+<span class="number">3600</span> * <span class="number">1000</span>)) <span class="comment">//设置令牌的过期时间</span></span><br><span class="line">		.compact();</span><br><span class="line">        System.out.println(jwt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 style="color:blue">解析JWT</h4>

<p><strong>解析JWT使用的方法</strong></p>
<ul>
<li><code>setSigningKey</code>：设置解析JWT的秘钥</li>
<li><code>parseClaimsJws</code>：将JWT作为该方法的参数</li>
<li><code>getBody</code>：获取到载荷部分的数据</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseJWT</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">Claims</span> <span class="variable">payload</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">		.setSigningKey(<span class="string">&quot;token&quot;</span>)		 <span class="comment">//输入JWT的秘钥</span></span><br><span class="line">        .parseClaimsJws(<span class="string">&quot;生成的JWT&quot;</span>)	<span class="comment">//将JWT放入parseClaimJws</span></span><br><span class="line">		.getBody();</span><br><span class="line">	System.out.println(payload);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong style="color:red">注意事项</strong></p>
<ul>
<li>JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是相同的。</li>
<li>如果JWT令牌解析校验时报错，则说明JWT被篡改或失效了，令牌非法。</li>
</ul>
</blockquote>
<h4 id="编写一个JWT工具类【JwtUtils】"><a href="#编写一个JWT工具类【JwtUtils】" class="headerlink" title="编写一个JWT工具类【JwtUtils】"></a>编写一个JWT工具类【JwtUtils】</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jwt</span></span><br><span class="line"><span class="comment">     * 使用Hs256算法, 私匙使用固定秘钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey jwt秘钥               [签名]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis jwt过期时间(毫秒)     [token的过期时间]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claims    设置的信息       [把json数据放进map然后当做参数传递]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String secretKey, <span class="type">long</span> ttlMillis, Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定签名的时候使用的签名算法，也就是header那部分</span></span><br><span class="line">        <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成JWT的时间,设置JWT的过期时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> System.currentTimeMillis() + ttlMillis;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置jwt的body</span></span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                <span class="comment">// 如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的</span></span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                <span class="comment">// 设置签名使用的签名算法和签名使用的秘钥</span></span><br><span class="line">                .signWith(signatureAlgorithm, secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">                <span class="comment">// 设置过期时间</span></span><br><span class="line">                .setExpiration(exp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析Token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey jwt秘钥 此秘钥一定要保留好在服务端, 不能暴露出去, 否则sign就可以被伪造</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token     加密后的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String secretKey, String token)</span> &#123;</span><br><span class="line">        <span class="comment">// 得到DefaultJwtParser</span></span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                <span class="comment">// 设置签名的秘钥</span></span><br><span class="line">                .setSigningKey(secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">                <span class="comment">// 设置需要解析的jwt</span></span><br><span class="line">                .parseClaimsJws(token).getBody();</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>





<h2 id="三、过滤器Filter"><a href="#三、过滤器Filter" class="headerlink" title="三、过滤器Filter"></a>三、过滤器Filter</h2><p>这了给出一篇简短高效的文章：<a href="https://segmentfault.com/a/1190000025152370" ><b style="color:blue">有关Filter的使用方法</b></a></p>
<h3 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h3><ul>
<li>概念：<span style="color:red">Filter过滤器</span>，是JavaWeb三大组件（Servlet、Filter、Listener）之一</li>
<li>过滤器可以把对资源的请求<span style="color:red">拦截</span>下来，从而实现一些特殊功能</li>
<li>过滤器一般完成一些<span style="color:red">通用</span>操作，比如：登录校验、统一编码处理、敏感字符处理等</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309221406046.png"
                      alt="image-20230922140633954"
                ></p>
<hr>



<h3 id="3-2、快速入门"><a href="#3-2、快速入门" class="headerlink" title="3.2、快速入门"></a>3.2、快速入门</h3><ol>
<li><p><strong>定义Filter：</strong>定义一个类，实现Filter接口，并重写其所有方法，Filter类上加上<code>@WebFilter</code>注解，配置拦截资源路径。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span>  <span class="comment">//配置拦截路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//初始化方法,只调用一次: 通常做环境以及资源的准备工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init 初始化开始了...&quot;</span>);</span><br><span class="line">        Filter.<span class="built_in">super</span>.init(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//每次拦截到请求之后调用，调用多次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截到了请求...【放行前逻辑】&quot;</span>);</span><br><span class="line">        <span class="comment">//doFilter是放行操作</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截到了请求...【放行后逻辑】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//销毁方法,只会调用一次: 通常做资源和环境的销毁工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destory 销毁执行了...&quot;</span>);</span><br><span class="line">        Filter.<span class="built_in">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>配置Filter：</strong>引导类上加<code>@ServletComponentScan</code>开启Servlet组件支持</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>		</span><br><span class="line"><span class="meta">@ServletComponentScan()</span>		<span class="comment">//扫描Servlet的组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<blockquote>
<ul>
<li><p>通常在<code>init</code>方法中做一些<strong>资源以及环境的准备</strong>工作</p>
</li>
<li><p>通常在<code>destory</code>方法做<strong>资源的释放以及环境的清理</strong>工作</p>
</li>
<li><p>在Spring启动类上加上注解<code>ServletComponentScan</code>：因为Filter是JavaWeb三大组件之一并不属于SpringBoot，因此想要在SpringBoot上使用JavaWeb的三大组件那就需要加上注解，加上注解就表示当前项目是支持Servlet相关组件的</p>
</li>
</ul>
</blockquote>
<hr>



<h3 id="3-3、Filter拦截路径"><a href="#3-3、Filter拦截路径" class="headerlink" title="3.3、Filter拦截路径"></a>3.3、Filter拦截路径</h3><table>
<thead>
<tr>
<th align="center">拦截路径</th>
<th align="center">URLPatterns值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">拦截具体路径</td>
<td align="center">&#x2F;login</td>
<td align="center">只有访问&#x2F;login路径时，才会被拦截</td>
</tr>
<tr>
<td align="center">目录拦截</td>
<td align="center">&#x2F;emps&#x2F;*</td>
<td align="center">访问&#x2F;emps下所有资源，都会被拦截</td>
</tr>
<tr>
<td align="center">拦截所有</td>
<td align="center">&#x2F;*</td>
<td align="center">访问所有资源，都会被拦截【</td>
</tr>
</tbody></table>
<h3 id="3-4、过滤器链"><a href="#3-4、过滤器链" class="headerlink" title="3.4、过滤器链"></a>3.4、过滤器链</h3><ul>
<li>介绍：一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个<b style="color:red">过滤器链</b></li>
<li>顺序：注解配置的Filter，优先级是按照过滤器类名（字符串）的自然排序</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309221415717.png"
                      alt="image-20230922141513652"
                ></p>
<p><strong>举个例子</strong></p>
<p>我创建了一个<code>AFilter</code>和一个<code>BFilter</code>因为两个拦截器的名字A比B靠前，所以过滤器链的先后顺序是</p>
<ul>
<li>浏览器请求资源：<code>浏览器</code>$\to$ <code>AFilter</code>$\to $<code>BFilter</code>$\to$<code>服务端</code></li>
<li>服务端返回资源：<code>浏览器</code>$\leftarrow$ <code>AFilter</code>$\leftarrow $<code>BFilter</code>$\leftarrow$<code>后端资源</code></li>
</ul>
<p><strong>定义的两个测试过滤器如下：</strong></p>
<center class="half" style="margin:0px;padding:0px">
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309221552065.png"
                      width="425px" height="300px"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309221553557.png"
                      width="425px" height="300px" 
                >
</center>

<p><strong>启动服务，发送请求，查看拦截结果可以看到是A拦截器先捕获到请求</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309221553756.png"
                      width="400px" height="300px"
                >



<h3 id="3-5-登录操作过滤器的实现-例子"><a href="#3-5-登录操作过滤器的实现-例子" class="headerlink" title="3.5 登录操作过滤器的实现(例子)"></a>3.5 登录操作过滤器的实现(例子)</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309221635480.png"
                      alt="image-20230922163502367"
                ></p>
<p><strong>步骤：</strong></p>
<ol>
<li>获取请求 url</li>
<li>判断请求 url 中是否包含login，如果包含，说明是登录操作，放行</li>
<li>获取请求头中的令牌（token）</li>
<li>判断令牌是否存在，如果不存在，返回错误结果（未登录）</li>
<li>解析 token ，如果解析失败，返回错误结果（未登录）</li>
<li>放行</li>
</ol>
<h4 style="color:blue">代码实现的基本逻辑</h4>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest)request;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> (HttpServletResponse)response;</span><br><span class="line">        <span class="comment">//1. 获取到请求的url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURI().toString();</span><br><span class="line">        log.info(<span class="string">&quot;拦截到请求,请求地址为: &#123;&#125;&quot;</span>,url);</span><br><span class="line">        <span class="comment">//2. 判断请求是否包含login，如果包含，则说明是登录操作，放行</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;login&quot;</span>))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;登录操作...&quot;</span>);</span><br><span class="line">            chain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 获取请求头中的令牌(token)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 判断令牌是否存在，如果不存在，返回错误结果(未登录)</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(token))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;请求头token为空，尚未登录...&quot;</span>);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动转换 对象--&gt;json--------》阿里巴巴的fastJSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            res.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 解析token如果解析失败，返回错误结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtil.parseJWT(<span class="string">&quot;token&quot;</span>,token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.info(<span class="string">&quot;解析token异常..&quot;</span>);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动转换 对象--&gt;json--------》阿里巴巴的fastJSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            res.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;令牌合法...&quot;</span>);</span><br><span class="line">        <span class="comment">//6. 放行</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="四、拦截器Interceptor"><a href="#四、拦截器Interceptor" class="headerlink" title="四、拦截器Interceptor"></a>四、拦截器Interceptor</h2><h3 id="4-1、概述"><a href="#4-1、概述" class="headerlink" title="4.1、概述"></a>4.1、概述</h3><ul>
<li><strong>概念：</strong>是一种动态拦截方法调用的机制，类似于过滤器。Spring框架提供的，用来动态拦截控制器方法的执行。</li>
<li><strong>作用：</strong>拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码</li>
</ul>
<h3 id="4-2、快速入门"><a href="#4-2、快速入门" class="headerlink" title="4.2、快速入门"></a>4.2、快速入门</h3><ol>
<li><p><strong>定义拦截器，实现HandlerInterceptor接口，并重写其所有方法</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>	<span class="comment">//交给IOC管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//目标资源方法执行前执行，返回true：放行，返回false：不放行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle方法执行了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//目标资源方法执行后执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle方法执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//视图渲染完毕后执行，最后执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;视图渲染完毕执行....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>注册拦截器</strong> </p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//表示当前类是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(loginCheckInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="4-3、Intercept拦截路径"><a href="#4-3、Intercept拦截路径" class="headerlink" title="4.3、Intercept拦截路径"></a>4.3、Intercept拦截路径</h3><ul>
<li><p>拦截器可以根据需求，配置不同的拦截路径：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span>&#123;</span><br><span class="line">    registry.addInterceptor(loginCheckInterceptor)</span><br><span class="line">        .addPathPatterns(<span class="string">&quot;/**&quot;</span>)			<span class="comment">//需要拦截那些资源</span></span><br><span class="line">        .excludePathPatterns(<span class="string">&quot;/login&quot;</span>);	<span class="comment">//不需要拦截那些资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><code>addPathPatterns()</code>：配置需要拦截的路径</li>
<li><code>excludePathPatterns()</code>：配置不需要拦截的路径</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">拦截路径</th>
<th align="center">含义</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x2F;*</td>
<td align="center">一级路径</td>
<td align="center">能匹配&#x2F;depts、&#x2F;emps、&#x2F;login、不能匹配&#x2F;depts&#x2F;1</td>
</tr>
<tr>
<td align="center">&#x2F;**</td>
<td align="center">任意级路径</td>
<td align="center">能匹配&#x2F;depts、&#x2F;depts&#x2F;1、&#x2F;depts&#x2F;1&#x2F;2</td>
</tr>
<tr>
<td align="center">&#x2F;depts&#x2F;*</td>
<td align="center">&#x2F;depts下的一级路径</td>
<td align="center">能匹配&#x2F;depts&#x2F;1，不能匹配&#x2F;depts&#x2F;1&#x2F;2、&#x2F;depts</td>
</tr>
<tr>
<td align="center">&#x2F;depts&#x2F;**</td>
<td align="center">&#x2F;depts下的任意路径</td>
<td align="center">能匹配&#x2F;depts、&#x2F;depts&#x2F;1、&#x2F;depts&#x2F;1&#x2F;2、不能匹配&#x2F;emps&#x2F;1</td>
</tr>
</tbody></table>
<h3 id="4-4、拦截器执行流程"><a href="#4-4、拦截器执行流程" class="headerlink" title="4.4、拦截器执行流程"></a>4.4、拦截器执行流程</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309222242453.png"
                      alt="image-20230922224235319"
                ></p>
<p>使用浏览器访问web服务器时</p>
<p>定义的过滤器Filter会首先拦截到请求，然后执行放行前的逻辑，接着执行放行操作（doFilter）</p>
<p>由于当前是基于SpiringBoot开发，所以放行之后会入到Spring的环境当中访问定义的Controller</p>
<p>因为Tomcat是一个Servlet容器，可以识别Servlet程序，但是不识别Controller</p>
<p>SpringWeb提供了一个核心的Servlet容器（称之为前端控制器：DispatcherServlet）</p>
<p>由DispatchServelt将请求转发给Controller然后执行对应的接口方法</p>
<p>但是因为定义了拦截器，所以请求先到拦截器然后才到Controller</p>
<blockquote>
<p><strong>Filter</strong>与<strong>Interceptor</strong><b style="color:red">区别</b></p>
<ul>
<li><strong>接口规范不同</strong>：过滤器需要实现Filter接口，而拦截器需要实现HandlerInterceptor接口</li>
<li><strong>拦截范围不同</strong>：过滤器Filter会拦截<strong>所有</strong>资源，而Interceptor只<strong>会拦截Spring环境中的资源</strong></li>
</ul>
</blockquote>
<h3 id="4-5、登录操作拦截器的实现（例子）"><a href="#4-5、登录操作拦截器的实现（例子）" class="headerlink" title="4.5、登录操作拦截器的实现（例子）"></a>4.5、登录操作拦截器的实现（例子）</h3><ol>
<li>获取请求 url</li>
<li>判断请求 url 中是否包含login，如果包含，说明是登录操作，放行</li>
<li>获取请求头中的令牌（token）</li>
<li>判断令牌是否存在，如果不存在，返回错误结果（未登录）</li>
<li>解析 token ，如果解析失败，返回错误结果（未登录）</li>
<li>放行</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//目标资源方法执行前执行，返回true：放行，返回false：不放行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest req, HttpServletResponse res, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 获取到请求的url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURI().toString();</span><br><span class="line">        log.info(<span class="string">&quot;拦截到请求,请求地址为: &#123;&#125;&quot;</span>,url);</span><br><span class="line">        <span class="comment">//2. 判断请求是否包含login，如果包含，则说明是登录操作，放行</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;login&quot;</span>))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;登录操作...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 获取请求头中的令牌(token)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 判断令牌是否存在，如果不存在，返回错误结果(未登录)</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(token))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;请求头token为空，尚未登录...&quot;</span>);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动转换 对象--&gt;json--------》阿里巴巴的fastJSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            res.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 解析token如果解析失败，返回错误结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtil.parseJWT(<span class="string">&quot;token&quot;</span>,token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.info(<span class="string">&quot;解析token异常..&quot;</span>);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动转换 对象--&gt;json--------》阿里巴巴的fastJSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            res.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;令牌合法...&quot;</span>);</span><br><span class="line">        <span class="comment">//6. 放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//目标资源方法执行后执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle方法执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//视图渲染完毕后执行，最后执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;视图渲染完毕执行....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<hr>
]]></content>
      <categories>
        <category>常见技术问题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Vue3跨域问题</title>
    <url>/2023/09/28/%E8%A7%A3%E5%86%B3Vue3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="解决Vue3跨域问题"><a href="#解决Vue3跨域问题" class="headerlink" title="解决Vue3跨域问题"></a>解决Vue3跨域问题</h1><blockquote>
<p> 今天敲码发现本地前端向后端发送请求时，发送请求出现跨域问题，联系广大网友发现两种解决跨域的方法</p>
</blockquote>
<h2 id="一、前端解决跨域"><a href="#一、前端解决跨域" class="headerlink" title="一、前端解决跨域"></a>一、前端解决跨域</h2><p><strong>前端axios向后端发起请求时，调试报错【跨域：CORS policy】</strong></p>
<center class="half">    
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309131700282.png"
                      alt="image-20230913170017182" width="465"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309131701343.png"
                      alt="image-20230913170130306" width="465"
                >
</center>

<p><strong>后端3000接口接收到请求但是返回值res前端无法接收</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309131703011.png"
                      alt="image-20230913170327960"
                ></p>
<h3 id="解决方法【反向代理】"><a href="#解决方法【反向代理】" class="headerlink" title="解决方法【反向代理】"></a>解决方法【反向代理】</h3><ul>
<li><strong>axios直接发送请求<code>/users</code>经反向代理发送到localhost:3000端口</strong></li>
<li><strong>找到<code>vue.config.js</code>文件并添加反向代理，将匹配到<code>/user</code>路径的请求<code>转发到3000端口</code></strong></li>
</ul>
<center class="half">    
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309131708296.png"
                      alt="image-20230913170017182" width="465"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309131711294.png"
                      alt="image-20230913170130306" width="465"
                >
</center>

<h3 id="问题解决成功…"><a href="#问题解决成功…" class="headerlink" title="问题解决成功…"></a>问题解决成功…</h3><ul>
<li><strong>配置反向代理后前端成功向后端发送请求并接受获取到的参数</strong></li>
</ul>
<center class="half">    
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309131713186.png"
                      alt="image-20230913170017182" width="465"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309131713943.png"
                      alt="image-20230913170130306" width="465"
                >
</center>



<h2 id="二、后端解决跨域"><a href="#二、后端解决跨域" class="headerlink" title="二、后端解决跨域"></a>二、后端解决跨域</h2><ul>
<li>此处选择基于Spring框架配置的后端配置类进行跨域问题的解决</li>
</ul>
<h3 id="创建配置类"><a href="#创建配置类" class="headerlink" title="创建配置类"></a>创建配置类</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mystudy.configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.java.Log;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span>          <span class="comment">//日志打印</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrosConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;跨域问题配置类设置成功...&quot;</span>);</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)	<span class="comment">//配置可以被跨域的路径，可以任意配置，可以具体到直接请求路径</span></span><br><span class="line">            <span class="comment">//允许所有的请求域名访问我们的跨域资源，可以固定单条或者多条内容</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            <span class="comment">//允许所有的请求方法访问该跨域资源服务器</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;HEAD&quot;</span>,<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;PUT&quot;</span>,<span class="string">&quot;DELETE&quot;</span>,<span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">            <span class="comment">//用于告知浏览器当withCredentials属性设置为true时，是否可以显示跨域请求返回的内容</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">//资源过期时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="问题解决成功…-1"><a href="#问题解决成功…-1" class="headerlink" title="问题解决成功…"></a>问题解决成功…</h3><ul>
<li><strong>前端照常发起请求，后端启动项目后配置类自动创建</strong></li>
</ul>
<center class="half">    
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309141107847.png"
                      alt="image-20230913170017182" width="470"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309141109801.png"
                      alt="image-20230913170130306" width="460"
                >
</center>

<hr>]]></content>
      <categories>
        <category>常见技术问题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>测试文章</title>
    <url>/2023/10/01/%E6%96%87%E7%AB%A0%E5%88%9B%E5%BB%BA%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="测试文章"><a href="#测试文章" class="headerlink" title="测试文章"></a>测试文章</h1><h2 id="文章篇头编辑简介"><a href="#文章篇头编辑简介" class="headerlink" title="文章篇头编辑简介"></a>文章篇头编辑简介</h2><p>使用 <code>cover</code>标签添加图片的链接即可作为文章的首页展示图</p>
<p>使用 <code>tags</code>给文章添加标签</p>
<p>使用 <code>categories</code> 来个文章归类</p>
<p>使用 <code>title</code> 给文章添加标题</p>
<p>使用 <code>expert</code> 来鬼文章添加首页简要</p>
<p>使用 <code>date</code> 标注文章发布时间</p>
]]></content>
      <categories>
        <category>测试标签1</category>
        <category>2标签测试</category>
      </categories>
      <tags>
        <tag>Tag1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-xv6实验记录(一)</title>
    <url>/2023/10/11/xv6%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="一、实验目的："><a href="#一、实验目的：" class="headerlink" title="一、实验目的："></a>一、实验目的：</h2><ol>
<li>借助Linux操作系统和qemu模拟器完成xv6平台的搭建</li>
<li>熟悉Linux一些命令的操作，熟悉vim的使用，会借助vim进行一些程序的编写并交入xv6中执行。</li>
<li>认识操作系统中的一些运行机理例如管道等。</li>
</ol>
<h2 id="二、实验内容："><a href="#二、实验内容：" class="headerlink" title="二、实验内容："></a>二、实验内容：</h2><ol>
<li>完成xv6平台的搭建。</li>
<li>完成sleep.c程序的编写。</li>
<li>完成pingpong.c程序的编写。</li>
<li>完成primes.c程序的编写。</li>
</ol>
<h2 id="三、实验平台的搭建【VMWare-Ubuntu-qemu-xv6】"><a href="#三、实验平台的搭建【VMWare-Ubuntu-qemu-xv6】" class="headerlink" title="三、实验平台的搭建【VMWare + Ubuntu + qemu + xv6】"></a>三、实验平台的搭建【VMWare + Ubuntu + qemu + xv6】</h2><ol>
<li><p><strong>安装VMWare</strong></p>
<p>官网在这：《<a class="link"   href="https://www.vmware.com/jp.html" >VMWare的官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>》。找寻CSDN其他文章，傻瓜式安装即可</p>
</li>
<li><p><strong>安装Ubuntu</strong></p>
<p>这里需要注意，装载的ubuntu镜像文件最好选择最新的20版本，如果选用老版本是无法直接安装qemu直接跑的，可能会有一些奇奇怪怪的问题，所以直接选用最新的版本，点击此处链接《 <a class="link"   href="https://mirrors.aliyun.com/ubuntu-releases/20.04/" >20版本的Ubuntu镜像文件 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>》进去链接下载后缀为iso的文件即可。【配置镜像文件到VMWare还是找CSDN傻瓜式配置即可】</p>
</li>
<li><p><strong>安装qemu</strong></p>
<p>先检测当前Ubuntu的版本是否可用，输入<code>ctrl+alt+T</code>打开终端输入指令</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">cat /etc/debian_version</span><br></pre></td></tr></table></figure></div>

<p>如果显示的是，就说明没有问题</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">bullseye/sid</span><br></pre></td></tr></table></figure></div>

<p>若是显示如下，则说明要去更新版本了</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">buster/...</span><br></pre></td></tr></table></figure></div>

<p><strong>1.升级apt并更换虚拟机的服务器镜像</strong>：输入如下指令</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></div>

<p><em><strong>2.换阿里的源</strong></em>：在Ubuntu20.04.3桌面版中，点击左下角“显示应用程序”，搜索“软件和更新”，点击进入。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309182028585.png"
                      alt="image-20230918202626239"
                ></p>
<p><strong>3.在“软件与更新”界面中的“Ubuntu软件”一栏， 选择“下载自”下拉菜单中的“其他站点”。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309182031280.png"
                      alt="image-20230918203121201"
                ></p>
<p>然后点击“选择最佳服务器”，系统会自动测试下载的服务器，等待一段时间后，选择系统给出的镜像服务器，软件源修改完成。【使用阿里云的够了】</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309182034263.png"
                      alt="image-20230918203337697"
                ></p>
<p><strong>4. 使用命令下载前置相关包</strong></p>
<p>这些包是要运行qemu不可或缺的前置组件[<a class="link"   href="https://zhuanlan.zhihu.com/p/267159664#ref_6" >6] <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，直接打开命令行终端复制粘贴运行即可安装。注意，这里安装包能否成功运行是和你的ubuntu版本有关系的</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo apt-get install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev</span><br></pre></td></tr></table></figure></div>

<p><strong>5. 安装riscv64-unknown-elf-gcc</strong></p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo apt install riscv64-unknown-elf-gcc</span><br></pre></td></tr></table></figure></div>

<p><em><strong>6. 安装xv6</strong></em></p>
<p>检查前面的组件是否安装成功…</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">riscv64-unknown-elf-gcc --version</span><br><span class="line">qemu-system-riscv64 --version</span><br></pre></td></tr></table></figure></div>

<p><strong>克隆xv6的源码仓库</strong></p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/mit-pdos/xv6-riscv.git</span><br></pre></td></tr></table></figure></div>

<p>7.<strong>使用</strong></p>
<p>先打开上述步骤中git clone下来的库，名称应该是xv6-riscv，cd进去，然后输入指令：</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309182038549.png"
                      alt="image-20230918203857506" style="zoom: 67%;" 
                >

<p>输入以后你应该会看到一大堆输出，这里表示我们的xv6系统正在编译</p>
<p>在这些输出完成以后，输入指令：</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">make qemu</span><br></pre></td></tr></table></figure></div>

<p>编译我们的qemu系统，输出如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309182040325.png"
                      alt="image-20230918204022277" style="zoom:67%;" 
                >

<p>最后如果看到终端显示出：init: starting sh，如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309182041488.png"
                      alt="image-20230918204114449"
                ></p>
<p>这就说明我们的安装成功啦，可以愉快地完成后续的任务了，还可以再输入ls验证一下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309182042046.png"
                      alt="image-20230918204203012" style="zoom:67%;" 
                ></li>
</ol>
<h2 id="3-1、Sleep（easy）"><a href="#3-1、Sleep（easy）" class="headerlink" title="3.1、Sleep（easy）"></a>3.1、Sleep（easy）</h2><h3 id="编写前提示"><a href="#编写前提示" class="headerlink" title="编写前提示"></a>编写前提示</h3><ul>
<li>开始编码之前，请阅读xv6手册第一章</li>
<li>查看文件夹<code>user/</code>中的一些其他程序（例如：<code>user/echo.c</code>、<code>user/grep.c</code>、<code>user/rm.c</code>）了解如何将获得的命令行参数传递给程序</li>
<li>若用户忘记传递参数，sleep程序应该打印一条错误的提示信息</li>
<li>命令行参数作为字符串传递，应使用<code>atoi</code>函数将其转为整数（具体查看<b style="color:red">user&#x2F;ulib.c中的atoi函数</b>）</li>
<li>参阅睡眠系统调用的xv6内核代码<code>kernel/sysproc.c</code>（<strong style="color:red">sys_sleep</strong>函数）</li>
<li>确保main中调用<code>exit()</code>以退出程序</li>
</ul>
<h3 id="编写后提示"><a href="#编写后提示" class="headerlink" title="编写后提示"></a>编写后提示</h3><p>假设你编写的程序名为“sleep.c”。在编写完成后：</p>
<ol>
<li>请将<strong>“sleep.c”拷贝至 xv6 源码目录下的 user&#x2F;文件夹下</strong></li>
<li>然后在 xv6 源码根目录下的 <code>Makefile </code>文件里，找到关键字<b style="color:red">UPROGS&#x3D;\</b>（可能<br>是第 179 行左右）,在其下面列出的多个以<code>&amp;U</code>开头的字符串的下方（可能是<br>第 195 行左右），添加一行<b style="color:red">&amp;U&#x2F;_sleep\</b>，并保存；</li>
<li>回到 xv6 的源码目录的根目录下，敲<code>make qemu</code>，以让 <code>sleep.c </code>得以编译并<br>在 xv6 内部形成可执行程序；</li>
<li>顺利进入到 xv6 的终端后，敲<code>“./sleep 5”</code>;</li>
</ol>
<h3 id="了解命令行如何传参"><a href="#了解命令行如何传参" class="headerlink" title="了解命令行如何传参"></a>了解命令行如何传参</h3><p><strong>查看源文件 echo 了解一下如何传递参数</strong></p>
<ul>
<li>查看此文件了解如何进行传递参数</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//echo.c源文件</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++)&#123;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>, argv[i], <span class="built_in">strlen</span>(argv[i]));</span><br><span class="line">    <span class="keyword">if</span>(i + <span class="number">1</span> &lt; argc)&#123;</span><br><span class="line">      <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过上述<code>echo.c</code>源码文件，了解到参数作用：</p>
<ol>
<li><code>argc</code>：表示的是命令行<strong>总的参数个数</strong></li>
<li><code>argv</code>：数组类型，按序保存了接收的所有参数，其中<strong>第 0 个是程序的全名</strong>，之后的参数就是用户输入的参数</li>
<li><code>write函数</code>：该函数接收三个参数<ul>
<li>第一个参数：0 表示 stdin，1 表示 stdout ，2 表示 stderr</li>
<li>第二个参数：输出的内容</li>
<li>第三个参数：输出内容的长度</li>
</ul>
</li>
</ol>
<p><strong>在命令行使用echo程序得到结果：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[roc@roclinux ~]$ echo &#x27;Hello World&#x27;			//输入</span><br><span class="line">Hello World										//输出</span><br></pre></td></tr></table></figure></div>



<h3 id="字符串转为整数（atoi函数）"><a href="#字符串转为整数（atoi函数）" class="headerlink" title="字符串转为整数（atoi函数）"></a>字符串转为整数（atoi函数）</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// atoi函数的源码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= *s &amp;&amp; *s &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    n = n*<span class="number">10</span> + *s++ - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="编写Sleep"><a href="#编写Sleep" class="headerlink" title="编写Sleep"></a>编写Sleep</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;				<span class="comment">//上述提到，这是参数总数，第一个是程序名字，第二个开始是用户输入的参数</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Error: please input one parameter..\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> time = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">sleep</span>(time);			<span class="comment">//此处是xv内核 sys_sleep 函数的调用</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>

<h2 id="3-2、pingpong（easy）"><a href="#3-2、pingpong（easy）" class="headerlink" title="3.2、pingpong（easy）"></a>3.2、pingpong（easy）</h2><p>该实验是一个典型的进程间通信应用。它的运行逻辑是：父进程使用<code>fork()</code>系统调用，创建一个子进程，然后使用管道<code>pipe</code>，在两者之间进行通信。</p>
<h3 id="编写前提示-1"><a href="#编写前提示-1" class="headerlink" title="编写前提示"></a>编写前提示</h3><ul>
<li>实验之前，建议在网络上了解 <b style="color:blue">fork、pipe、write、read、getpid</b>函数的作用</li>
<li>使用<b style="color:red">pipe</b>创建管道</li>
<li>使用<b style="color:red">fork</b>创建子进程</li>
<li>使用<b style="color:red">read</b>读取pipe，并使用<b style="color:red">write</b>写入pipe</li>
<li>使用<b style="color:red">getpid</b>查找调用进程的进程ID</li>
<li>程序编写完成后，参考上述Sleep实验的程序编译部分，把 pingpong 程序放到对应的 xv6<br>源码目录，然后修改 Makefile 文件，再编译运行</li>
</ul>
<hr>

<h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h4><ul>
<li>fork创建一个子进程并完全复制父进程，且<b style="color:red">子进程是从fork后面的指令开始执行的。</b></li>
</ul>
<p>为已存在的进程创建一个子进程，而原进程称为父进程。调用该函数后，内核开始分配新的内存块和内核数据结构给子进程。</p>
<p><strong>特点：</strong></p>
<ol>
<li>调用一次，返回两次并发执行</li>
<li>有独立使用的地址空间</li>
<li>函数fork返回值：向父进程返回子进程的ID，向子进程返回 0<ul>
<li>在父进程中，fork() 返回新创建子进程的进程pid；</li>
<li>在子进程中，fork() 返回0；</li>
<li>如果出现错误，fork() 返回一个负值；</li>
</ul>
</li>
<li>不同的进程有一个<strong>唯一</strong>的不同进程pid，通过 getpid() 函数可以知道当前进程pid，可以说我们就是通过这个pid知道当前所在进程。</li>
</ol>
<p><strong>fork 调用失败的原因：</strong></p>
<ol>
<li>系统中有太多进程。</li>
<li>实际用户的进程数超过限制。</li>
</ol>
<blockquote>
<p>每个进程各自有<b style="color:red">不同的用户地址空间</b>,任何一个进程的全局变量在另一个进程中都看不到，所以<b style="color:blue">进程之间要交换数据必须通过内核</b>,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。 </p>
</blockquote>
<hr>

<h4 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h4><p><code>pipe()</code> 函数是一个用于创建无名管道</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span></span>;		<span class="comment">//函数原型</span></span><br></pre></td></tr></table></figure></div>

<p><strong>参数：</strong></p>
<ul>
<li><p><code>pipefd[2]</code>：一个整数数组，包含了两个文件描述符。</p>
<p><strong>文件描述符是操作系统中用于标识和操作文件或I&#x2F;O资源的抽象概念。它是一个非负整数，通常作为索引或句柄，用于访问文件、套接字、管道和其他I&#x2F;O设备。</strong></p>
</li>
<li><p><code>pipefd[0]</code> 用于读取，<code>pipefd[1]</code> 用于写入。</p>
</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>成功时返回0。</li>
<li>失败时返回-1，并设置 <code>errno</code> 来指示错误的原因。</li>
</ul>
<p><strong>那么管道如何实现进程间的通信？</strong></p>
<ol>
<li>父进程创建管道，得到两个⽂件描述符指向管道的两端</li>
<li>父进程fork出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。</li>
<li>《0-读，1-写》父进程关闭pipefd[0],子进程关闭pipefd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。</li>
</ol>
<p><strong>需要使用的函数已经在前置知识有介绍，知识略浅，需要在网络上了解更多详细知识，此处不在赘述</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> parent_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> child_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//调用函数创建管道,并判断是否创建成功</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pipe</span>(parent_fd) == <span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">&quot;Error: parernt_pipe not create...&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">pipe</span>(child_fd) == <span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">&quot;Error: child_pipe not create...&quot;</span>);</span><br><span class="line">    <span class="comment">//创建子进程,获取进程ID</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="comment">//创建数据容器,保存数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;<span class="comment">//获取的PID == 0时为子进程</span></span><br><span class="line">        <span class="built_in">read</span>(parent_fd[<span class="number">0</span>],buf,<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: reacive %s\n&quot;</span>,<span class="built_in">getpid</span>(),buf);</span><br><span class="line">        <span class="built_in">write</span>(child_fd[<span class="number">1</span>],<span class="string">&quot;ping&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;ping&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//PID != 0 时为父进程</span></span><br><span class="line">        <span class="built_in">write</span>(parent_fd[<span class="number">1</span>],<span class="string">&quot;pang&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;pang&quot;</span>));</span><br><span class="line">        <span class="built_in">read</span>(child_fd[<span class="number">0</span>],buf,<span class="number">4</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d: reacive %s\n&quot;</span>,<span class="built_in">getpid</span>(),buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(parent_fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(parent_fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(child_fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(child_fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意进程死锁，上述if - else中的读和写语句要错位，如果两个进程一开始都是读文件，即会造成进程死锁</strong></p>
</blockquote>
<h2 id="3-3、质数primes"><a href="#3-3、质数primes" class="headerlink" title="3.3、质数primes"></a>3.3、质数primes</h2><h3 id="筛法思想"><a href="#筛法思想" class="headerlink" title="筛法思想"></a>筛法思想</h3><p>筛法就是将2的倍数，3的倍数，5的倍数等等，一一筛除，剩下的就是素数了。</p>
<p>创建文件描述符和创建一个管道，再创建一个子进程，子进程把管道的写端口描述符映射到原来的描述符标准输出 1 上。循环通过 write 系统调用把 2 到 35 写入管道。父进程等待子进程把数据写入完毕后，父进程把管道的读端口描述符映射到原来的描述符标准输入 0 上。在编写一个 primes 函数，调用此函数实现递归筛选的过程。</p>
<p>对于编写 primes 函数。定义两个整型变量，存放从管道获取的数，定义管道描述符数组。从管道中读取数据，第一个数（2，3，5等）一定是素数，直接打印出来，然后创建另一个管道和子进程，子进程通过管道描述符映射，关闭不必要的文件描述符节约资源。再循环读取原管道中的数据，如果该数与原管道的第一个取模后不为 0 ，则重新写入刚刚创建的管道。父进程等待此子进程执行完毕，再次调用重定向函数关闭不必要的文件描述符，再递归调用 primes 函数重复以上筛选过程，即可将管道中所有素数打印出来。</p>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><ol>
<li>父进程A生成【2-35】之间的所有数字，包括2和35</li>
<li>向A的子进程B进行输出（通过管道）</li>
<li>B对[2-35]进行筛选，打印出第一个质数2</li>
<li>B把剩下的数字（通过）通过管道传递给B的子进程C</li>
<li>C打印出第二个质数，也就是3</li>
<li>重复（4）和（5）的过程，直到2 - 35 之间的质数全部在终端输出</li>
</ol>
<h3 id="一些提示"><a href="#一些提示" class="headerlink" title="一些提示"></a>一些提示</h3><ul>
<li><p>请小心关闭进程不需要的文件描述符，因为否则，您的程序将在第一个进程达到35之前在资源中运行xv6。</p>
</li>
<li><p>一旦第一个进程达到35，它应该等待直到整个管道终止，包括所有子代，孙代为止。因此，仅在打印完所有输出之后以及在所有其他准备工作都退出之后，才应退出主要准备工作。</p>
</li>
<li><p>提示：当管道的写侧关闭时，read返回零。</p>
</li>
<li><p>将32位<b style="color:blue">（4字节）</b>int直接写入管道是最简单的，而不是使用格式化的ASCII I &#x2F; O。</p>
</li>
<li><p>您仅应在需要时才在管道中创建进程。<br>将程序添加到Makefile中的UPROGS。</p>
</li>
</ul>
<blockquote>
<p>此处选取算法<b style="color:red">埃拉托斯特尼筛法</b>来实现快速筛选质数</p>
<p>建议在网络上了解上述算法的原理再回来看该程序会更容易理解一点</p>
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309182009125.png"
                      alt="image-20230918200904069" style="zoom: 67%;" 
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用指针的形式，让所有子进程能够读取同一块空间的数据，num记录目前还需要筛选数子的个数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;  <span class="comment">// 筛选到最后一个数字的时候，该数字已经是质数了，所以程序也就结束了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;prime is %d\n&quot;</span>,*<span class="built_in">array</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>], i ,temp;</span><br><span class="line">    <span class="type">int</span> prime = *<span class="built_in">array</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime is %d\n&quot;</span>,prime);;</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;		<span class="comment">//父进程创建一个子进程(一)，子进程循环写入剩余的每一个数字到管道</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            temp = *(<span class="built_in">array</span> + i);</span><br><span class="line">            write(fd[<span class="number">1</span>], (<span class="type">char</span> *)(&amp;temp), <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;		<span class="comment">//父进程再创建一个子进程（二），子进程读取上面一个子进程写入管道的数据</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;		<span class="comment">//该变量记录本轮没有被筛掉的数字个数</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">while</span>(read(fd[<span class="number">0</span>], buffer, <span class="number">4</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            temp = *((<span class="type">int</span> *)buffer);</span><br><span class="line">            <span class="keyword">if</span>(temp % prime != <span class="number">0</span>)&#123;</span><br><span class="line">                *<span class="built_in">array</span> = temp;</span><br><span class="line">                <span class="built_in">array</span> = <span class="built_in">array</span> + <span class="number">1</span>;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        solution(<span class="built_in">array</span> - count,count);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> argv[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> target[<span class="number">34</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; <span class="number">34</span>;i++) target[i] = i + <span class="number">2</span>;</span><br><span class="line">    solution(target, <span class="number">34</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h2 id="四、实验心得"><a href="#四、实验心得" class="headerlink" title="四、实验心得"></a>四、实验心得</h2><blockquote>
<p>安装环境消耗的时间感觉是这次作业中花费时间最长的，其次就是实验中的第三题，递归+子进程+管道通信确实需要耗费时间去思考如何解题。不过也挺好，一步步看源码然后模仿着去操作，体会到了操作系统的奇妙，比起书上的理论知识，实际动手感悟更深。</p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-xv6实验记录(三)</title>
    <url>/2023/10/11/xv6%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95(%E4%B8%89)/</url>
    <content><![CDATA[<h1 id="2021-xv6实验记录-三"><a href="#2021-xv6实验记录-三" class="headerlink" title="2021-xv6实验记录(三)"></a>2021-xv6实验记录(三)</h1><blockquote>
<p>本次实验，将进行三个子任务：</p>
<ol>
<li>系统调用性能优化</li>
<li>打印进程 1 的页表</li>
<li>跟踪进程的内存访问位。</li>
</ol>
<p>官方实验指南：<a class="link"  style="color:red"  href="https://pdos.csail.mit.edu/6.828/2021/labs/pgtbl.html" >在这里！！！ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>官方参考书：<a class="link"   href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf"  style="color:blue">点击此处！！ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h2>开始实验之前首先切换到官方的pgtbl分支</h2>

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout pgtbl</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span></span><br></pre></td></tr></table></figure></div>



<h2 id="实验【Speed-up-system-calls】"><a href="#实验【Speed-up-system-calls】" class="headerlink" title="实验【Speed up system calls】"></a>实验【Speed up system calls】</h2><h3 id="一、实验前提示"><a href="#一、实验前提示" class="headerlink" title="一、实验前提示"></a>一、实验前提示</h3><ul>
<li>在<code>kernel/proc.c</code>文件里的 <code>alloc_proc()</code>函数里，加入对 <code>USYSCALL </code>页面的创建过<br>程（<strong>可以仿照 TRAPFRAME 页面的构建方法来写相关的代码</strong>），并在之后对 usyscall<br>结构体的 pid 成员变量进行赋值</li>
<li>在<code>kernel/proc.c</code>文件里的 <code>proc_pagetable()</code>里，加入对 <code>USYSCALL</code> 页面的映射过<br>程并赋予适当的权限（<strong>可以仿照 trapframe 和 TRAMPOLINE 的映射方法</strong>）；</li>
<li>映射的方法用到的核心函数为 <b style="color:red">mappages()</b>;</li>
<li>在进程退出或者分配内存失败的情况下，<b style="color:blue">记得释放 USYSCALL 和相关的页面</b>，防止<br>内存泄漏（<strong>例如在 freeproc()函数里添加相关的内存撤销&#x2F;回收语句</strong>）；</li>
<li>根据上述描述，ugetpid()的核心逻辑其实就是在用户层对进程的 USYSCALL 页面进<br>行访问，可以查看 xv6 源码目录下的 user&#x2F;pgtbltest.c 文件是如何对其进行<br>访问的</li>
</ul>
<hr>

<p><strong>简述题意：</strong>给系统调用函数<code>ugetpid()</code>提速，方法是给每个进程的单独内存空间里添加一个<code>USYSCALL</code>页面，而里头存放一个系统函数会经常使用的数据，这里专指<code>pid</code>，而我们把<code>pid</code>存放在<code>struct usyscall</code>中。</p>
<ul>
<li>通过上述方法，<code>ugetpid()</code>需要用到<code>pid</code>时，会在<strong>用户态</strong>使用<code>USYSCALL</code>页面<strong>直接调用，而不用切换到内核态</strong></li>
</ul>
<h3 id="二、实验过程"><a href="#二、实验过程" class="headerlink" title="二、实验过程"></a>二、实验过程</h3><p>首先打开<code>kernel/memlayout.h</code>，可以看到下述代码</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* kernel/memlayout.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)  <span class="comment">// USYSCALl = 3FFFFFD000</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">usyscall</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>这个USYSCALL页一定是独立于进程页表的一个页，把定义加到<code>kernel/proc.h</code>中：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">usyscall</span> *usyscall;  		<span class="comment">//新添加的代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后去<code>kernel/proc.c</code>中初始化这个页面，<code>allocproc()</code>中会分配一些页，在这个函数里面分配出需要的<code>usyscall</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">proc</span> * <span class="built_in">allocproc</span>(<span class="type">void</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//原有代码</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 新添加的代码！！</span></span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)<span class="built_in">kalloc</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">freeproc</span>(p);</span><br><span class="line">        <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// An empty user page table.</span></span><br><span class="line">    p-&gt;pagetable = <span class="built_in">proc_pagetable</span>(p);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>用户态寻址的时候都要经过页表硬件的翻译，所以<code>usyscall</code>也要映射在进程的<code>pagetable</code>上，刚刚加入的位置的下面就有<code>proc_pagetable(p)</code>用于<code>map page</code>，在<code>kernel/proc.c</code>中加入映射逻辑</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">pagetable_t</span> <span class="title">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//新添加的代码</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mappages</span>(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall),</span><br><span class="line">                 PTE_R | PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">uvmunmap</span>(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">uvmunmap</span>(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">uvmfree</span>(pagetable, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>映射完成了之后就要对其进行初始化，回到<code>kernel/proc.c</code>，加入代码</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">proc</span> * <span class="built_in">allocproc</span>(<span class="type">void</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//新添加的代码</span></span><br><span class="line">    p-&gt;usyscall-&gt;pid = p-&gt;pid;	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>根据提示：进程回收的时候，该页面也要释放，在<code>freeproc()</code>中加入释放即可</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">freeproc</span><span class="params">(<span class="keyword">struct</span> proc*p)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新添加的代码</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;usyscall) <span class="built_in">kfree</span>((<span class="type">void</span> *)p-&gt;usyscall);</span><br><span class="line">    p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>并且在函数<code>proc_freepagetable()</code>中解除映射，不然启动的时候会报<code>freewalk panic</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//新添加的代码</span></span><br><span class="line">  <span class="built_in">uvmunmap</span>(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">uvmfree</span>(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="三、实验结果的验证"><a href="#三、实验结果的验证" class="headerlink" title="三、实验结果的验证"></a>三、实验结果的验证</h3><p>打开终端，make qemu启动xv6系统，检查是否报错，如果没有遇见错误，在 xv6 的终端里敲：<code>pgtbltest </code>或者<code>./pgtbltest</code>，看看是否能够通过对 ugetpid()的调用测试  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310111613541.png"
                      alt="image-20231011161305492"
                ></p>
<hr>





<h2 id="实验【Print-a-page-table】"><a href="#实验【Print-a-page-table】" class="headerlink" title="实验【Print a page table】"></a>实验【Print a page table】</h2><h3 id="一、实验前提示-1"><a href="#一、实验前提示-1" class="headerlink" title="一、实验前提示"></a>一、实验前提示</h3><ul>
<li>输出页表功能由 <code>vmprint()</code>函数实现，它的参数只有一个，类型为<br><code>pagetable_t</code>，其定义在<code>kernel/riscv.h</code>的末尾；</li>
<li>在 <code>kernel/exec.c </code>文件里，在<code>return argc;</code>语句之前，也即是 exec()函数的<br>接近末尾处，加入<b style="color:blue">if(p-&gt;pid&#x3D;&#x3D;1)  vmprint(p-&gt;pagetable)；</b>，以便只打印 pid 为 1 进程页表；</li>
<li>在 <code>kernel/vm.c</code> 里，找个地方实现<code> vmprint()</code>,它的逻辑就是输出当前进程的<br>页表；</li>
<li>在文件<code>kernel/vm.c</code>里，有个现有的函数叫做 <code>freewalk()</code>——你的 <strong>vmprint()</strong><br><strong>代码可以参考和借鉴</strong>；</li>
<li>在文件<code>kernel/riscv.h</code>的末尾，有几个宏定义，在解题的时候会用的上；</li>
<li>输出内存地址的时候，可以在 printf 里用%p 来格式化指针（地址），它的好<br>看程度和图 3.2 的地址输出一样美丽；</li>
</ul>
<h3 id="二、实验过程-1"><a href="#二、实验过程-1" class="headerlink" title="二、实验过程"></a>二、实验过程</h3><p><strong>实验解决思路：递归遍历页表，碰到有效的就遍历进下一层页表</strong></p>
<p>根据提示在<code>kernel/vm.c</code>文件中添加如下代码</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vmprintlevel</span><span class="params">(<span class="type">pagetable_t</span> pt, <span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *delim = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">2</span>) delim = <span class="string">&quot;..&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">1</span>) delim = <span class="string">&quot;.. ..&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) delim = <span class="string">&quot;.. .. ..&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">        <span class="type">pte_t</span> pte = pt[i];</span><br><span class="line">        <span class="keyword">if</span> ((pte &amp; PTE_V)) &#123;</span><br><span class="line">            <span class="comment">//  this PTE points to a lower level page table.</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s%d: pte %p pa %p\n&quot;</span>, delim, i, pte, <span class="built_in">PTE2PA</span>(pte));</span><br><span class="line">            uint64 child = <span class="built_in">PTE2PA</span>(pte);</span><br><span class="line">            <span class="keyword">if</span> (level != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">vmprintlevel</span>((<span class="type">pagetable_t</span>)child, level - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pt);</span><br><span class="line">    <span class="built_in">vmprintlevel</span>(pt, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>记得在<code>kernel/defs.h</code>文件中添加函数的声明</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span>            <span class="title">vmprintlevel</span><span class="params">(<span class="type">pagetable_t</span> pt, <span class="type">int</span> level)</span></span>;	<span class="comment">//新添加</span></span><br><span class="line"><span class="function"><span class="type">void</span>            <span class="title">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pt)</span></span>;					<span class="comment">//新添加</span></span><br></pre></td></tr></table></figure></div>

<p>写完了函数还要记得在make的时候启动输出因此找到kernel&#x2F;exec.c <code>文件里，在</code>return argc;&#96;语句之前，也即是 exec()函数的<br>接近末尾处，加入<b style="color:blue">if(p-&gt;pid&#x3D;&#x3D;1)  vmprint(p-&gt;pagetable)；</b></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件kernel/exec.c</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ... </span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pid==<span class="number">1</span>) &#123;			<span class="comment">//新添加的代码</span></span><br><span class="line">  	<span class="built_in">vmprint</span>(p-&gt;pagetable);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line">  ...</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h3 id="三、实验结果的验证-1"><a href="#三、实验结果的验证-1" class="headerlink" title="三、实验结果的验证"></a>三、实验结果的验证</h3><p><span style="color:blue">此时我们在终端使用make qemu启动后可以看到如下效果：</span></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310111605794.png"
                      alt="image-20231011160530691"
                ></p>
<hr>







<h2 id="实验【Detecting-which-pages-have-been-accessed】"><a href="#实验【Detecting-which-pages-have-been-accessed】" class="headerlink" title="实验【Detecting which pages have been accessed】"></a>实验【Detecting which pages have been accessed】</h2><h3 id="一、实验前提示-2"><a href="#一、实验前提示-2" class="headerlink" title="一、实验前提示"></a>一、实验前提示</h3><ul>
<li>在 <code>kernel/sysproc.c </code>里实现 <code>pgaccess()</code>系统调用，名为<code> sys_pgaccess()</code><br>如果你已经切换到了本 lab 的代码分支，那么该系统调用的声明已经完成，你只<br>需实现该系统调用本体即可；</li>
<li>有两个内核函数可以用到，分别是：<code>argaddr()</code>和 <code>argint()</code>，它们的作用都是把用<br>户层的系统调用参数通过一个安全的方法导入至内核使用；这两个内核函数的定<br>义在 <code>kernel/syscall.c</code></li>
<li>因为这里用 <code>bitmask </code>来保存指定页面范围内的访问情况，所以 <code>pgaccess()</code>系统调<br>用在内核层收集完信息后，我们需要把这个信息拷贝回用户层，这里用到的一个<br>函数叫做 <code>copyout()</code>，它的实现在 <code>kernel/vm.c </code>的末尾<strong>（还记得 lab2 中的</strong><br><strong>Sysinfo 吗？）</strong></li>
<li>可以设定 <code>pgaccess()</code>系统调用所涉及的页面数量最大值，比如 32；</li>
<li><code>kernel/vm.c </code>文件里的 <code>walk()</code>函数可以在本次任务中发挥较大的用处，它的执行<br>逻辑是：给定一个 VA（Virtual Address），返回其在指定页表内的 L0 级页目录的<br>PTE 地址；你可以用它来检测返回值的对应访问位是否为 1；</li>
<li>需要在 <code>kernel/riscv.h</code> 里定义页表的访问位，也即<code> PTE_A</code>，否则你的默认页表里<br>没有 <code>PTE_A </code>位可供系统调用查询</li>
<li>在 pgaccess()执行期间，确保 PTE_A 为 1 的页面在 check 之后置其为 0</li>
</ul>
<h3 id="二、实验过程-2"><a href="#二、实验过程-2" class="headerlink" title="二、实验过程"></a>二、实验过程</h3><p><strong>主要思路就是用户调用系统调用的时候，我们去查找页表，获得对应的<code>PTE</code>，然后检查<code>PTE_A</code>(需要自己定义)，然后决定是否在答案设置对应有效位。</strong></p>
<p>首先我们自己定义<code>PTE_A</code>，打开<code>kernel/riscv.h</code>文件</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L <span class="string">&lt;&lt; 4) // 1 -&gt;</span> user can access</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6) <span class="comment">// 改行代码为新添加的内容</span></span></span><br></pre></td></tr></table></figure></div>

<p> 在<code>kernel/sysproc.c</code>中完善<code>sys_pgaccess()</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="function">uint64 <span class="title">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;			<span class="comment">//函数体的内容都是新添加的	</span></span><br><span class="line">    <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">    uint64 buf;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    uint64 ans;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;buf) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">argint</span>(<span class="number">1</span>, &amp;number) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">argaddr</span>(<span class="number">2</span>, &amp;ans) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pgaccess</span>((<span class="type">void</span>*)buf, number, (<span class="type">void</span>*)ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>看到上一步使用了pgaccess函数因此在<code>kernel/defs.h</code>中需要添加声明</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">pgaccess</span><span class="params">(<span class="type">void</span> *pg, <span class="type">int</span> number, <span class="type">void</span> *store)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>然后去<code>kernel/proc.c</code>中加入<code>pgaceess()</code>的定义</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新添加的函数</span></span><br><span class="line"><span class="function">uint64 <span class="title">pgaccess</span><span class="params">(<span class="type">void</span> *pg, <span class="type">int</span> number, <span class="type">void</span> *store)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pagetable_t</span> pagetable = p-&gt;pagetable;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        pte = <span class="built_in">walk</span>(pagetable, ((uint64)pg) + (uint64)PGSIZE * i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (pte != <span class="number">0</span> &amp;&amp; ((*pte) &amp; PTE_A)) &#123;</span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            *pte ^= PTE_A;  <span class="comment">// clear PTE_A</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copyout</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">copyout</span>(pagetable, (uint64)store, (<span class="type">char</span> *)&amp;ans, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为上一步过程使用了一个walk函数因此我们需要在<code>kernel/defs.h</code>中添加walk函数的声明</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">pte_t</span>*          <span class="title">walk</span><span class="params">(<span class="type">pagetable_t</span>,uint64,<span class="type">int</span>)</span></span>;	<span class="comment">//新添加的函数声明</span></span><br></pre></td></tr></table></figure></div>



<h3 id="三、实验结果的验证-2"><a href="#三、实验结果的验证-2" class="headerlink" title="三、实验结果的验证"></a>三、实验结果的验证</h3><p><b style="color:green">使用命令<code>make grade</code>检测前面三个实验是否完全通过</b></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310111657766.png"
                      alt="image-20231011165721153"
                ></p>
<blockquote>
<p>注意：需要创建一个文件<code>answers-pgtbl.txt</code>文件用于保存答案否则make grade的时候会在在test answer - pgtbl.txt报错，同时创建了文件之后在里面<strong>随便敲入多个字符</strong>保留答案输出空间即可：</p>
<p>即：在xv6 - labs - 2021目录下</p>
<ol>
<li>touch answers-pgtbl.txt</li>
<li>vim answers-pgtbl.txt</li>
<li>随便敲入多个字符即可</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-xv6实验记录(二)</title>
    <url>/2023/10/11/xv6%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="xv6实验记录-二"><a href="#xv6实验记录-二" class="headerlink" title="xv6实验记录(二)"></a>xv6实验记录(二)</h1><h2 id="一、实验目的："><a href="#一、实验目的：" class="headerlink" title="一、实验目的："></a>一、实验目的：</h2><ol>
<li>了解系统调用</li>
</ol>
<h2 id="二、实验内容："><a href="#二、实验内容：" class="headerlink" title="二、实验内容："></a>二、实验内容：</h2><ol>
<li>完成<code>trace()</code>的新系统调用</li>
<li>完成<code>sysinfo()</code>的新系统调用</li>
</ol>
<h2 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h2><h3 id="1-trace-系统调用的实现"><a href="#1-trace-系统调用的实现" class="headerlink" title="(1)trace()系统调用的实现"></a>(1)trace()系统调用的实现</h3><p><strong>(1)首先切换分支，保存实验记录，并清除编译记录</strong></p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">git checkout syscall</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure></div>

<p>根据实验提示，在MakeFile文件中找到<code>UPROGS</code>并添加<code>$U/_trace\</code>打开<code>user</code>目录可以看到存在一个<code>user/trace.c</code>文件，观察该文件的源码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">trace</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>])) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>看到这一段代码中存在<code>trace()</code>方法的调用【该方法来自<strong>user.h</strong>】，trace函数接收一个<strong>int</strong> 类型的整数，返回值类型也是<strong>int</strong>，如果执行失败返回值为-1。</p>
<hr>


<p><strong>(2)在<code>user/user.h</code>中添加函数原型</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trace</span><span class="params">(<span class="type">int</span>)</span></span>;		<span class="comment">//NEW ADD</span></span><br></pre></td></tr></table></figure></div>

<p>在<code>user/usys.pl</code>中添加trace的入口</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">entry</span>(<span class="string">&quot;trace&quot;</span>);		<span class="comment">//NEW ADD</span></span><br></pre></td></tr></table></figure></div>

<p>在<code>syscall.h</code>中添加宏定义</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace 22 <span class="comment">//NEW ADD</span></span></span><br></pre></td></tr></table></figure></div>

<hr>



<p><strong>(3)在proc结构体(在<code>kernel/proc.h</code>)里面添加一个新变量用来存储跟踪号，然后在fork()的时候把结构体里新增加的变量也给复制过去，这样就达到了传参的目的。新的变量是不需要加锁的，因为只会被自己所在的进程使用，所以放在<code>char name[16]</code>之后</strong></p>
<p>修改<code>kernel/proc.h</code>添加变量存储跟踪号</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  <span class="comment">// ,,</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               </span><br><span class="line">  <span class="type">char</span> mask[<span class="number">23</span>];           <span class="comment">//NEW ADD</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>打开<code>kernel/sysproc.c</code>添加一个trace函数的具体实现</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">uint64				<span class="comment">//新添加的函数定义</span></span><br><span class="line"><span class="built_in">sys_trace</span>(<span class="type">void</span>)&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argint</span>(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="type">char</span> *mask = p-&gt;mask;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; <span class="number">23</span> &amp;&amp; n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span>)&#123;</span><br><span class="line">      mask[i++] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      mask[i++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>打开<code>kernel/proc.c</code>文件修改<code>fork()</code>函数在函数中添加一句 <code>safestrcpy(np-&gt;mask, p-&gt;mask, sizeof(p-&gt;mask));</code>即可</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *np;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = <span class="built_in">allocproc</span>()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">uvmcopy</span>(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">freeproc</span>(np);</span><br><span class="line">    <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">safestrcpy</span>(np-&gt;mask, p-&gt;mask, <span class="built_in">sizeof</span>(p-&gt;mask));		<span class="comment">//NEW ADD</span></span><br><span class="line">    </span><br><span class="line">  ......</span><br><span class="line">      </span><br></pre></td></tr></table></figure></div>

<p>为了将trace打印出来，修改<code>kernel/syscall.c</code>中的<code>syscall()</code>函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span>;		<span class="comment">//NEW ADD</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> </span>= &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  [SYS_close]   sys_close,</span><br><span class="line">  [SYS_trace]   sys_trace, <span class="comment">// NEW ADD</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *syscall_names[<span class="number">23</span>] = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;fork&quot;</span>,<span class="string">&quot;exit&quot;</span>,<span class="string">&quot;wait&quot;</span>,<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;read&quot;</span>,<span class="string">&quot;kill&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;exec&quot;</span>,<span class="string">&quot;fstat&quot;</span>,<span class="string">&quot;chdir&quot;</span>,<span class="string">&quot;dup&quot;</span>,<span class="string">&quot;getpid&quot;</span>,<span class="string">&quot;sbrk&quot;</span>,<span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;uptime&quot;</span>,<span class="string">&quot;open&quot;</span>,<span class="string">&quot;write&quot;</span>,<span class="string">&quot;mknod&quot;</span>,<span class="string">&quot;unlink&quot;</span>,<span class="string">&quot;link&quot;</span>,<span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;close&quot;</span>,<span class="string">&quot;trace&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">syscall</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="type">char</span>* syscall_name;       <span class="comment">// NEW ADD</span></span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="built_in">NELEM</span>(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(p-&gt;mask) &gt; <span class="number">0</span> &amp;&amp; p-&gt;mask[num] == <span class="string">&#x27;1&#x27;</span>)&#123;		<span class="comment">// NEW ADD</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num],p-&gt;trapframe-&gt;a0); </span><br><span class="line">    &#125;                                                                    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>测试效果</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">trace <span class="number">32</span> grep hello README</span><br><span class="line">trace <span class="number">2147483647</span> grep hello README</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309251247136.png"
                      alt="image-20230925124713029"
                ></p>
<div class="highlight-container" data-rel="Q"><figure class="iseeu highlight q"><table><tr><td class="code"><pre><span class="line">./grade-lab-syscall trace</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309251248997.png"
                      alt="image-20230925124857961"
                ></p>
<hr>



<h3 id="2-sysinfo-系统调用的实现"><a href="#2-sysinfo-系统调用的实现" class="headerlink" title="(2)sysinfo()系统调用的实现"></a>(2)sysinfo()系统调用的实现</h3><p><strong>（1）将<code>$U/_sysinfotest</code>添加到 Makefile 中的 UPROGS</strong></p>
<p><strong>（2）在<code>user/user.h</code>中声明sysinfo() 函数的原型，您需要预先声明<code>struct sysinfo</code>的存在：</strong>修改<code>user/user.h</code>需要在user.h里再声明一次struct sysinfo的原因是：在参数列表里的参数是看不见本文件外面定义的struct的。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span>			<span class="comment">//New ADD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *)</span>;			<span class="comment">//NEW ADD</span></span><br></pre></td></tr></table></figure></div>

<p><strong>（3）在<code>user/usys.pl</code>中添加sysinfo的入口</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">entry</span>(<span class="string">&quot;sysinfo&quot;</span>);		<span class="comment">//NEW ADD</span></span><br></pre></td></tr></table></figure></div>

<p><strong>（4）在<code>syscall.h</code>中添加宏定义</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sysinfo 23</span></span><br></pre></td></tr></table></figure></div>

<p><strong>（5）修改<code>kernel/syscall.c</code>中的<code>syscall()</code>函数</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_info</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">[SYS_sysinfo] sys_info,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* syscall_names[] = &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  [SYS_sysinfo] <span class="string">&quot;sys_info&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>（6）编辑<code>sysproc.c</code>文件，先添加函数体</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_info</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>（7）打开<code>sysproc.c</code>文件添加<code>\#include &quot;sysinfo.h&quot;</code></strong></p>
<p><strong>（8）要获得空闲内存的数目，请向<code>kernel/kalloc.c</code>添加一个函数<code>kfreemem</code></strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get free memory bytes by count freelist</span></span><br><span class="line"><span class="function">uint64 <span class="title">kfreemem</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line">  uint64 count = <span class="number">0</span>; </span><br><span class="line">​</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span> (r) &#123;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">return</span> count * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>（9）要获得进程的数量，请在<code>kernel/proc.c</code>中添加一个函数<code>proc_num()</code></strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get the number of processes whose state is not UNUSED</span></span><br><span class="line"><span class="function">uint64 <span class="title">proc_num</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line">  uint64 count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>（10）在<code>kernel/defs.h</code>文件中添加函数原型</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64          <span class="title">proc_num</span><span class="params">(<span class="type">void</span>)</span></span>;         <span class="comment">//NEW ADD</span></span><br><span class="line"><span class="function">uint64          <span class="title">kfreemem</span><span class="params">(<span class="type">void</span>)</span></span>;         <span class="comment">//NEW ADD</span></span><br></pre></td></tr></table></figure></div>

<p><strong>（11）修改<code>kernel/sysproc.c</code>文件的<code>sys_info()</code>的函数体</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_info</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sysinfo</span> info;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  info.freemem = <span class="built_in">kfreemem</span>();</span><br><span class="line">  info.nproc = <span class="built_in">proc_num</span>();</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// copy info(kernel space) to addr(user space)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">copyout</span>(<span class="built_in">myproc</span>()-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;info, <span class="built_in">sizeof</span>(info)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>测试效果</strong></p>
<div class="highlight-container" data-rel="Q"><figure class="iseeu highlight q"><table><tr><td class="code"><pre><span class="line">./grade-lab-syscall sysinfo</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309251307278.png"
                      alt="image-20230925130757238"
                ></p>
<h2 id="四、总测试"><a href="#四、总测试" class="headerlink" title="四、总测试"></a>四、总测试</h2><ul>
<li>在xv6-lab-2021的目录下新建time.txt文件，之后输入一个整数代表你做实验的时间，单位是小时。之后就可以运行make grade来测试自己的成绩。</li>
</ul>
<div class="highlight-container" data-rel="Q"><figure class="iseeu highlight q"><table><tr><td class="code"><pre><span class="line">make grade		<span class="comment">//用来测试自己的实验成绩</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309251314583.png"
                      alt="image-20230925131445543"
                ></p>
<p><strong>如果上述测试失败，检查错误原因是否是因为</strong></p>
<ol>
<li><p>trace的<strong>打印格式</strong>有无错误</p>
</li>
<li><p>机器<strong>硬件不行</strong>，测试时间长，qemu认为超时【解决方法打开目录下的<code>gradelib.py</code>文件调整timeout时间】</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202309251316024.png"
                      alt="image-20230925131647952"
                ></p>
</li>
</ol>
<blockquote>
<p><b style="color:red">实验心得</b>：</p>
<p>在Xv6操作系统中完成新增系统调用 <code>trace()</code> 和 <code>sysinfo()</code> 的的实现不仅让我更深入地理解了操作系统内核的工作方式，还提供了一种方法来收集有关系统状态和进程信息的数据。查看源码的过程令我头疼的同时也令我切实的学会了一些东西，了解了系统的部分运行效果</p>
<p>首先，实现 <code>trace()</code> 调用允许用户程序追踪其他进程的系统调用和退出情况。我学到了如何在进程控制块（PCB）中存储额外的信息，以便程序可以访问。这个经验提高了我对内核数据结构的理解</p>
<p>另一个 <code>sysinfo()</code> 系统调用，提供了关于系统整体状态的信息，系统启动时间、总的调用次数等。实现这个系统调用，我了解了操作系统内核如何维护系统状态信息，并且学会了如何将这些信息传递给用户程序。这对于监控系统性能和行为非常有用。</p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka快速入门案例</title>
    <url>/2023/10/13/Eureka%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="一、模块了解"><a href="#一、模块了解" class="headerlink" title="一、模块了解"></a>一、模块了解</h2><p>此处有<code>UserController</code>在<code>user-service</code>模块下，该<code>Controller</code>实现接收路径参数<code>&#123;id&#125;</code>并返回数据库查询到的<code>user</code>数据，向<code>localhost:8082/user/1</code>即可查询到<code>id = 1</code>的user信息</p>
<center class="half">    
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310121935297.png"
                      width="700"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310121938764.png"
                      width="200"
                >
</center>

<p>同时有<code>OrderController</code>在<code>order-service</code>模块下，该<code>Controller</code>可以实现接收路径参数<code>&#123;orderId&#125;</code>并返回数据库的查询内容，向<code>localhost:8080/order/101</code>可以查询到数据</p>
<center class="half">    
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310121927799.png"
                      width="700"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310121930746.png"
                      width="200"
                >
</center>



<h2 id="二、工具类RestTemplate引入"><a href="#二、工具类RestTemplate引入" class="headerlink" title="二、工具类RestTemplate引入"></a>二、工具类RestTemplate引入</h2><p><strong>我们可以看到在上述结果返回的order数据中有一项是user的信息：</strong></p>
<ol>
<li><strong>那么两个模块如何进行通信使得order能够获取到user的信息并封装返回呢？</strong></li>
<li>因为order需要获取到user的数据，因此需要在order-service的启动类中获取到一个<strong>工具类【RestTemplate】</strong>用于<strong>向user端发送http请求</strong>【<strong>类似于前端发送ajax请求</strong>】</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310121945655.png"
                      alt="image-20231012194520311"
                ></p>
<p>那么现在既然有了可以发送http请求的工具类，我们就可以令<code>order-service</code>向<code>user-service</code>发送请求获取数据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310121948322.png"
                      alt="image-20231012194819910"
                ></p>
<p>此时我们再次请求刚刚的链接地址获取order的数据<code>localhost:8080/order/101</code>，可以看到此时成功的封装到了user的数据，也就证明我们的<code>order-service</code>模块成功向<code>user-service</code>模块发送请求并获取到了数据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310121950090.png"
                      alt="image-20231012195057979"
                ></p>
<p>既然这样就可以做到模块分离并获取数据，那Eureka的存在是为了什么呢？仔细想想：在order-service模块发送请求的时候请求地址的url是<strong>固定</strong>写死的把？那岂不是模块order-service只能固定的获取<code>url = localhost:8082/user</code>的<code>user-service</code>数据吗？若是某一天该user-service服务挂掉了岂不是全部与该url有请求关系的模块都出现问题？并且要是一瞬间有大量的请求请求到同一个地址上的服务器，那么这台服务器也能保证不出现问题？</p>
<p>因此，一般会有多个user-service但是不同地址的url地址的服务模块同时运行。</p>
<p><strong>即：多台服务器维护同一个数据库A，当需要使用到该数据库A时，可以访问不同的服务器，而不是单一的服务器。</strong></p>
<p><strong>Eureka的作用就是维护这样多台服务器并且能够将请求平均的转发到这些服务器，避免一台服务器的访问量突然暴增</strong></p>
<p><strong>那么既然要使用到Eureka技术，请看接下来的快速入门代码操作</strong></p>
<h2 id="三、搭建Eureka服务"><a href="#三、搭建Eureka服务" class="headerlink" title="三、搭建Eureka服务"></a>三、搭建Eureka服务</h2><p>我们首先再创建一个模块用于搭建Eureka服务，此处将该模块称为【eureka-server】</p>
<p>既然要使用该技术，首先得引入pom坐标</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122004550.png"
                      alt="image-20231012200445165"
                ></p>
<p>然后在<code>application.yml</code>文件中对Eureka进行配置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122008430.png"
                      alt="image-20231012200827191"
                ></p>
<p>要令springboot能够使用识别到Eureka则需要在启动类上添加注解<code>@EnableEurekaServer</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122010489.png"
                      alt="image-20231012201043215"
                ></p>
<p>然后我们启动服务，并在浏览器输入我们刚刚配置的服务地址<code>localhost:10086</code>，可以看到如下画面就证明Eureka注册成功</p>
<p>并且注意到在 注册的名字就是我们在配置项application.yml中配置的name</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122013339.png"
                      alt="image-20231012201327189"
                ></p>
<h2 id="四、服务注册到Eureka"><a href="#四、服务注册到Eureka" class="headerlink" title="四、服务注册到Eureka"></a>四、服务注册到Eureka</h2><p>现在有了Eureka，我们就可以运行多个user-service服务【注册】供order-service服务使用了。首先要将这两个模块注册到Eureka，那么就要将坐标<code>spring-cloud-starter-netflix-eureka-client</code>引入二者的pom文件，并编写application.yml配置文件</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span> </span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka/</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122020051.png"
                      alt="image-20231012202005789"
                ></p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span> </span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka/</span></span><br></pre></td></tr></table></figure></div>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122335432.png"
                      alt="image-20231012233552318"
                ></p>
<p>再次启动服务查看上述的<code>order-service</code>与<code>user-service</code>模块成功注册到Eureka</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122340895.png"
                      alt="image-20231012234043852"
                ></p>
<p>idea如何在一台主机上运行两个同样的<code>user-service</code>服务呢？首先我们将<code>user-service</code>运行，然后查看service面板，点击右键选中<code>Copy Configuration</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122342440.png"
                      alt="image-20231012234230361"
                ></p>
<p>配置面板中更换Name，并且在<strong>VM Option配置项中将服务换一个端口运行</strong>【<strong>此处选择8081</strong>】点击OK即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122342189.png"
                      alt="image-20231012234253145"
                ></p>
<p>查看service，并打开Eureka管理面板，可以看到8081和8082端口的服务都成功注册了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122345483.png"
                      alt="image-20231012234517362"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122346126.png"
                      alt="image-20231012234619083"
                ></p>
<p>两个user-service的成功注册代表着我们可以让order-service模块随机的选择一个user-service的端口发起请求获取数据，但是需要开启负载均衡【只需要在order-service的RestTemplate的Bean获取类上加上注释<code>LoadBalanced</code>】即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122348778.png"
                      alt="image-20231012234831665"
                ></p>
<h2 id="五、服务的发现"><a href="#五、服务的发现" class="headerlink" title="五、服务的发现"></a>五、服务的发现</h2><p>同时修改代码，用注册的user-service的服务名来替代原来的 ip + 端口。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122352242.png"
                      alt="image-20231012235226039"
                ></p>
<p>再次发送请求<code>localhost:8080/order/101</code>可以看到还是成功获取到数据说明上述配置是成功的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310122355477.png"
                      alt="image-20231012235524439"
                ></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务入门篇(一)</title>
    <url>/2023/10/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="一、认识微服务"><a href="#一、认识微服务" class="headerlink" title="一、认识微服务"></a>一、认识微服务</h2><h3 id="1-1、-单体架构"><a href="#1-1、-单体架构" class="headerlink" title="1.1、 单体架构"></a>1.1、 单体架构</h3><ul>
<li><strong>单体架构：</strong>将业务的所有功能集中在一个项目中开发，打成一个包部署</li>
<li><strong>优点：</strong><ol>
<li>架构简单</li>
<li>部署成本低</li>
</ol>
</li>
<li><strong>缺点：</strong><ol>
<li>耦合度高</li>
</ol>
</li>
</ul>
<h3 id="1-2、分布式架构"><a href="#1-2、分布式架构" class="headerlink" title="1.2、分布式架构"></a>1.2、分布式架构</h3><ul>
<li><strong>分布式架构：</strong>根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务</li>
<li><strong>优点：</strong><ol>
<li>降低服务耦合</li>
<li>有利于服务升级拓展</li>
</ol>
</li>
<li><strong>需要考虑的问题：</strong><ol>
<li>服务拆分粒度如何？【如何拆分？哪些服务作为独立模块？哪些业务合并一起？】</li>
<li>服务集群地址如何维护？</li>
<li>服务之间如何实现远程调用？</li>
<li>服务健康状态如何感知？</li>
</ol>
</li>
</ul>
<h3 id="1-3、微服务"><a href="#1-3、微服务" class="headerlink" title="1.3、微服务"></a>1.3、微服务</h3><ul>
<li>微服务是一种经过良好架构设计的<strong>分布式</strong>架构方案，微服务架构特征：<ol>
<li><strong>单一职责</strong>：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发</li>
<li><strong>面向服务</strong>：微服务对外暴露业务接口</li>
<li><strong>自治</strong>：团队独立、技术独立、数据独立、部署独立</li>
<li><strong>隔离性强</strong>：服务调用做好隔离、容错、降级，避免出现级联问题</li>
</ol>
</li>
</ul>
<h3 id="1-4、微服务技术对比"><a href="#1-4、微服务技术对比" class="headerlink" title="1.4、微服务技术对比"></a>1.4、微服务技术对比</h3><p>微服务这种方案需要技术框架来落地，全球的互联网公司都在积极尝试自己的微服务落地技术。在国内最知名的就是SpringCloud和阿里巴巴的Dubbo</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Dubbo</th>
<th align="center">SpringCloud</th>
<th align="center">SpringCloudAlibaba</th>
</tr>
</thead>
<tbody><tr>
<td align="center">注册中心</td>
<td align="center">zookeeper、redis</td>
<td align="center">Eureka、Consul</td>
<td align="center">Nacos、Eureka</td>
</tr>
<tr>
<td align="center">服务远程调用</td>
<td align="center">Dubbo协议</td>
<td align="center">Feign（http协议）</td>
<td align="center">Dubbos、Feign</td>
</tr>
<tr>
<td align="center">配置中心</td>
<td align="center">无</td>
<td align="center">SpringCloudConfig</td>
<td align="center">SpringCloudConfig、Nacos</td>
</tr>
<tr>
<td align="center">服务网关</td>
<td align="center">无</td>
<td align="center">SpringCloudGateway、Zuul</td>
<td align="center">SpringCloudGateway、Zuul</td>
</tr>
<tr>
<td align="center">服务监控和保护</td>
<td align="center">dubbo-admin，功能弱</td>
<td align="center">Hystrix</td>
<td align="center">Sentinel</td>
</tr>
</tbody></table>
<hr>

<h2 id="二、Eureka"><a href="#二、Eureka" class="headerlink" title="二、Eureka"></a>二、Eureka</h2><h3 id="2-0、Eureka的快速入门案例"><a href="#2-0、Eureka的快速入门案例" class="headerlink" title="2.0、Eureka的快速入门案例"></a>2.0、Eureka的快速入门案例</h3><p>因为案例篇幅使用图片较多因此请点击<a href = "https://handsomexianc.github.io/2023/10/13/Eureka%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/">此处</a>跳转至页面</p>
<hr>

<h3 id="2-1、Eureka原理分析"><a href="#2-1、Eureka原理分析" class="headerlink" title="2.1、Eureka原理分析"></a>2.1、Eureka原理分析</h3><p>在Eureka架构中，微服务角色有两类：</p>
<ul>
<li>EurekaServer：服务端，注册中心<ul>
<li>记录服务信息</li>
<li>心跳监控</li>
</ul>
</li>
<li>EurekaClient：客户端<ul>
<li>povider：服务提供者<ul>
<li>注册自己的信息到EurekaServer</li>
<li>每隔30s向EurekaServer发送心跳</li>
</ul>
</li>
<li>consumer：服务消费者<ul>
<li>根据服务名称从EurekaServer拉取服务列表</li>
<li>基于服务列表做负载均衡，选中一个微服务后发起远程调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-2、搭建EurekaServer"><a href="#2-2、搭建EurekaServer" class="headerlink" title="2.2、搭建EurekaServer"></a>2.2、搭建EurekaServer</h3><p>搭建EurekaServer服务步骤如下：</p>
<ol>
<li><p>创建项目，引入<code>spring-cloud-starter-netflix-eureka-server</code>的依赖</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>编写启动类，添加<code>@EnableEurekaServer</code>注解</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>添加application.yml文件，编写下面的配置</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eurekaserver</span> </span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka/</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="2-3、服务注册到Eureka"><a href="#2-3、服务注册到Eureka" class="headerlink" title="2.3、服务注册到Eureka"></a>2.3、服务注册到Eureka</h3><p>将自己的服务【此处我选用user-service】注册到EurekaServer步骤如下</p>
<ol>
<li><p>在user-service项目中引入<code>spring-cloud-starter-netflix-eureka-client</code>的依赖</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在application.yml文件，编写如下配置：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> </span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka/</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>是不是发现写在application.yml文件中的配置与搭建Eureka服务的配置一模一样？那是因为Eureka本身也是需要注册的因此配置文件书写内容基本一致，但是二者需要引入的pom坐标是不一样的。</p>
<h3 id="2-4、服务发现"><a href="#2-4、服务发现" class="headerlink" title="2.4、服务发现"></a>2.4、服务发现</h3><p><strong>在order-service完成服务拉取</strong></p>
<p>服务拉取是基于服务名称获取服务列表，然后在对服务列表做负载均衡</p>
<ol>
<li><p>修改OrderService的代码，修改访问的URL路径，用服务名代替ip、端口：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId();</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在order-service项目的启动类OrderApplication中的RestTemplate添加<strong>负载均衡</strong>注解：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<hr>


<h2 id="三、Ribbon负载均衡"><a href="#三、Ribbon负载均衡" class="headerlink" title="三、Ribbon负载均衡"></a>三、Ribbon负载均衡</h2><h3 id="3-1、负载均衡的原理"><a href="#3-1、负载均衡的原理" class="headerlink" title="3.1、负载均衡的原理"></a>3.1、负载均衡的原理</h3><p>还记得上述的<a href="">快速入门案例</a>中服务发现中使用到的访问URL路径<code>http:://userservice/user/...</code>吗？</p>
<p>我们只是指定了服务的名称<code>userservice</code>而不是<code>ip+端口</code>并且在RestTemplate的Bean上添加了注解<code>@LoadBalanced</code>就自动完成了服务的拉取以及请求的负载均衡。因此有以下两点需要注意：</p>
<ol>
<li>什么时候完成了服务的拉取？</li>
<li>什么时候完成了请求的负载均衡？</li>
<li>负载均衡的原理和策略？</li>
</ol>
<p><strong>负载均衡的流程如图所示</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310131532780.png"
                      alt="image-20231013153219657"
                ></p>
<p><strong>Ribbon内部原理</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310131549052.png"
                      alt="image-20231013154859990"
                ></p>
<h3 id="3-2、负载均衡的策略"><a href="#3-2、负载均衡的策略" class="headerlink" title="3.2、负载均衡的策略"></a>3.2、负载均衡的策略</h3><table>
<thead>
<tr>
<th align="center">内置负载均衡规则类</th>
<th align="center">规则描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>RoundRobinRule</strong></td>
<td align="center">简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则</td>
</tr>
<tr>
<td align="center"><strong>AvailabilityFilteringRule</strong></td>
<td align="center">对以下两种服务器进行忽略：<br />（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。<br />（2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置AvailabilityFilteringRule规则的客户端也将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionLimit属性进行配置</td>
</tr>
<tr>
<td align="center"><strong>WeightedResponseTimeRule</strong></td>
<td align="center">为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择</td>
</tr>
<tr>
<td align="center">ZoneAvoidanceRule</td>
<td align="center">以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个支架等。而后再对Zone内的多个服务做轮询</td>
</tr>
<tr>
<td align="center">BestAvailableRule</td>
<td align="center">忽略哪些短路的服务器。并选择并发数较低的服务器</td>
</tr>
<tr>
<td align="center">RandomRule</td>
<td align="center">随机选择一个可用的服务器</td>
</tr>
<tr>
<td align="center">RetryRule</td>
<td align="center">重试机制的选择逻辑</td>
</tr>
</tbody></table>
<p>Ribbon默认的负载均衡策略为：RoundRobinRule【简单的轮询服务列表】</p>
<h4>默认负载均衡策略的验证——例子</h4>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310131617635.png"
                      alt="image-20231013161740584"
                ></p>
<p>并让<code>order-service</code>向<code>user-service</code>发送四次查询请求</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310131619797.png"
                      alt="image-20231013161930752"
                ></p>
<p>因为默认的负载均衡策略为轮询所以可以推断：</p>
<p>8082端口的服务将会接收第一次和第三次的请求，查看8082服务接收请求的情况，推断正确。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310131621941.png"
                      alt="image-20231013162116768"
                ></p>
<p>8081端口的服务将会接收第二次和第四次的请求，查看8081服务接收请求的情况，推断正确。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310131621681.png"
                      alt="image-20231013162131503"
                ></p>
<p>上述成功验证了Ribbon默认的负载均衡的策略为轮询。</p>
<hr>



<p><strong>那么如何修改Ribbon负载均衡的查询机制呢？</strong></p>
<p>通过定义IRule实现可以修改负载均衡的规则，有两种方式：</p>
<ol>
<li><p>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule【全局配置】</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该配置是全局的，order-service不仅是对user-service模块发送请求时使用的负载均衡机制为random，其他也是一样。</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>创建上述的规则Bean之后再次发送四次请求作为验证，可以看到此时8081端口只接受到了第四次的请求，验证成功。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310131629900.png"
                      alt="image-20231013162909676"
                ></p>
</li>
<li><p>配置文件的方式：在order-service的application.yml文件中，添加新的配置也可以修改规则</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该配置项配置在order-service的application.yml文件</span></span><br><span class="line"><span class="comment"># 说明order-service模块对user-service模块发送请求时使用下述的负载均衡策略</span></span><br><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="3-3、饥饿加载"><a href="#3-3、饥饿加载" class="headerlink" title="3.3、饥饿加载"></a>3.3、饥饿加载</h3><p>RIbbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p>
<p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#开启饥饿模式</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span> <span class="comment">#指定对userservice这个服务饥饿加载</span></span><br></pre></td></tr></table></figure></div>





<hr>

<h2 id="四、Nacos注册中心"><a href="#四、Nacos注册中心" class="headerlink" title="四、Nacos注册中心"></a>四、Nacos注册中心</h2><p>Nacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高</p>
<h3 id="4-1、服务注册到Nacos"><a href="#4-1、服务注册到Nacos" class="headerlink" title="4.1、服务注册到Nacos"></a>4.1、服务注册到Nacos</h3><ol>
<li><p>在父工程中添加spring-cloud-alibaba的管理依赖：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>注释掉order-service和user-service原有的eureka依赖</p>
</li>
<li><p>添加nacos的客户端依赖</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos的客户端依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>修改user-service&amp;order-service中的application.yml文件注释掉eureka地址，添加nacos的地址</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span>	<span class="comment">#服务端的地址</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>然后打开Nacos的控制台可以看到服务的注册结果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310131856451.png"
                      alt="image-20231013185623234"
                ></p>
<h3 id="4-2、修改服务的集群属性"><a href="#4-2、修改服务的集群属性" class="headerlink" title="4.2、修改服务的集群属性"></a>4.2、修改服务的集群属性</h3><p><strong>Nacos服务分级存储模型</strong></p>
<ol>
<li>一级是服务，例如userservice</li>
<li>二级是集群，例如杭州或上海</li>
<li>三级是实例，例如杭州机房的某台部署了userservice的服务器</li>
</ol>
<p><strong>如何设置实例的集群属性</strong></p>
<ol>
<li><p>修改application.yml，添加如下内容</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span>		<span class="comment">#设置集群的属性为HZ</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在Nacos控制台可以看到集群变化，可以看到服务归属的集群已经变成了HZ</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310131910380.png"
                      alt="image-20231013191052293"
                ></p>
</li>
<li><p>然后在order-service中设置负载均衡的IRule为NacosRule，这个规则优先会寻找与自己同集群的服务：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment">#负载均衡规则</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>注意设置user-service的权重为1</p>
</li>
</ol>
<hr>

<h3 id="4-3、NacosRule负载均衡策略"><a href="#4-3、NacosRule负载均衡策略" class="headerlink" title="4.3、NacosRule负载均衡策略"></a>4.3、NacosRule负载均衡策略</h3><ol>
<li>优先选择同集群服务实例列表</li>
<li>本地集群找不到提供者，才去其他集群寻找，并且会报警告</li>
<li>确定了可用实例列表后，再采用随机负载均衡挑选实例</li>
</ol>
<p><strong>根据权重负载均衡</strong></p>
<p>实际部署中会出现这样的场景：</p>
<ul>
<li>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求</li>
</ul>
<p><strong>Nacos提供了权重配置来控制访问评率，权重越大则访问频率越高</strong></p>
<ol>
<li><p>在Nacos控制台可以设置实例的权重值，首先选中实例后面的编辑按钮</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310131934449.png"
                      alt="image-20231013193407360"
                ></p>
</li>
<li><p>将权重设置为0.1，测试可以发现8081被访问到的评率大大降低</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310131935751.png"
                      alt="image-20231013193506673"
                ></p>
</li>
</ol>
<p><strong>总结：</strong></p>
<ol>
<li>Nacos控制台可以设置实例的权重值，0-1之间</li>
<li>同集群内的多个实例，权重越高被访问的频率越高</li>
<li>权重设置为0则完全不会被访问</li>
</ol>
<hr>

<h3 id="4-4、环境隔离-namespace"><a href="#4-4、环境隔离-namespace" class="headerlink" title="4.4、环境隔离-namespace"></a>4.4、环境隔离-namespace</h3><ul>
<li>namespace用来做环境隔离</li>
<li>每一个namespace都有唯一的id</li>
<li>不同的namespace下的服务是不可见的</li>
</ul>
<ol>
<li><p>首先在Nacos的控制台点击命名空间，看到目前只有public的命名空间，然后点击新建</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310131955267.png"
                      alt="image-20231013195510156"
                ></p>
</li>
<li><p>填入新建的信息，ID不填的话会默认使用UUID生成一个随机ID</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310131957841.png"
                      alt="image-20231013195753755"
                ></p>
</li>
<li><p>修改order-service到application.yml文件，添加namespace：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">SH</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">531e06b8-9430-4375-84ec-3439ffe9f161</span> <span class="comment">#新创建命名空间生成的ID</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>重启order-service后再来查看控制台</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310132001031.png"
                      alt="image-20231013200154923"
                ></p>
</li>
<li><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310132002711.png"
                      alt="image-20231013200254593"
                ></p>
</li>
</ol>
<h3 id="4-5、Nacos与Eureka区别"><a href="#4-5、Nacos与Eureka区别" class="headerlink" title="4.5、Nacos与Eureka区别"></a>4.5、Nacos与Eureka区别</h3><ul>
<li>Nacos与Eureka的共同点<ol>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ol>
</li>
<li>Nacos与Eureka的区别<ol>
<li>Nacos支持服务端主动检测提供者的状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表变更消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP模式</li>
</ol>
</li>
</ul>
<h3 id="4-6、Nacos配置管理"><a href="#4-6、Nacos配置管理" class="headerlink" title="4.6、Nacos配置管理"></a>4.6、Nacos配置管理</h3><h4>统一配置管理</h4>

<p><strong>创建配置管理文件</strong></p>
<p><strong>第一步</strong>：在Nacos中添加配置信息，点击 配置列表 $\to$点击 $+$</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310132027992.png"
                      alt="image-20231013202758859"
                ></p>
<p><strong>第二步</strong>：在弹出的表单中填写配置信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310132034142.png"
                      alt="image-20231013203431036"
                ></p>
<h3 id="4-7、微服务的配置拉取"><a href="#4-7、微服务的配置拉取" class="headerlink" title="4.7、微服务的配置拉取"></a>4.7、微服务的配置拉取</h3><ol>
<li><p>引入Nacos的配置管理客户端依赖：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos配置管理依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在userservice中的resource目录添加一个<code>bootstrap.yml</code>文件，这个文件时引导文件，优先级高于application.yml</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span>	<span class="comment">#服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span>	<span class="comment">#开发环境，这里是dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span>	<span class="comment">#Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span>	<span class="comment">#文件后缀名</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>然后在user-service中将pattern.dateformat这个属性注入到UserController中做测试：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//注入nacos中的配置属性</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//编写controller，通过日期格式化器来格式化现在时间并返回</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().format(</span><br><span class="line">        	DateTimeFormatter.ofPattern(dateformat,Locale.CHINA)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><strong>将配置交给Nacos管理的步骤</strong></p>
<ol>
<li>在Nacos中添加配置文件</li>
<li>在微服务中引入nacos的config依赖</li>
<li>在微服务中添加bootstrap.yml文件，配置nacos的地址、当前环境、服务名称、文件后缀名。这些决定了程序启动时去nacos读取哪个文件</li>
</ol>
<h3 id="4-8、微服务的热更新"><a href="#4-8、微服务的热更新" class="headerlink" title="4.8、微服务的热更新"></a>4.8、微服务的热更新</h3><p>Nacos中的配置文件变更后，微服务无需重启就可以感知。不过需要通过下面两种配置来实现</p>
<ul>
<li><p><strong>方式一</strong>：在<code>@Value</code>注入的变量所在类上添加注解<code>@RefreshScope</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>方式二</strong>：使用<code>@ConfigurationProperties</code>注解</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<p>注意事项：</p>
<ul>
<li>不是所有的配置都适合放到配置中心，维护起来比较麻烦</li>
<li>建议将一些关键参数，需要运行时调整的参数放到nacos配置中心，一般都是自定义配置</li>
</ul>
</blockquote>
<hr>

<h2 id="五、http客户端Feign"><a href="#五、http客户端Feign" class="headerlink" title="五、http客户端Feign"></a>五、http客户端Feign</h2><p>Feign是一个声明式的http客户端，其作用是简化实现http请求发送。</p>
<h3 id="5-1、基于Feign的远程调用"><a href="#5-1、基于Feign的远程调用" class="headerlink" title="5.1、基于Feign的远程调用"></a>5.1、基于Feign的远程调用</h3><p><strong>使用Feign的步骤如下</strong>：</p>
<ol>
<li><p>引入依赖</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在需要发送请求的服务的启动类添加注解开启Feign的功能：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>编写Feign的客户端：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClients</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p>
<ul>
<li>服务名称：userservice</li>
<li>请求方式：GET</li>
<li>请求路径：&#x2F;user&#x2F;{id}</li>
<li>请求参数：Long id</li>
<li>返回值类型：User</li>
</ul>
</li>
<li><p>用Feign客户端代替RestTemplate</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span>&#123;</span><br><span class="line">    <span class="comment">//1. 查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">    <span class="comment">//2. 利用Feign发起http请求，查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.findById(order.getUserId());</span><br><span class="line">    <span class="comment">//3. 封装User到order</span></span><br><span class="line">    order.setUser(user);</span><br><span class="line">    <span class="comment">//4. 返回</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="5-2、Feign自定义配置"><a href="#5-2、Feign自定义配置" class="headerlink" title="5.2、Feign自定义配置"></a>5.2、Feign自定义配置</h3><p>Feign运行自定义配置来覆盖默认配置，可以修改的配置如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">作用</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">feign.Logger.Level</td>
<td align="center">修改日志级别</td>
<td align="center">包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>
</tr>
<tr>
<td align="center">feign.codec.Decoder</td>
<td align="center">响应结果的解析器</td>
<td align="center">http远程调用的结果做解析，例如解析json字符串为Java对象</td>
</tr>
<tr>
<td align="center">feign.codec.Encoder</td>
<td align="center">请求参数编码</td>
<td align="center">将请求参数编码，便于通过http请求发送</td>
</tr>
<tr>
<td align="center">feign.Contract</td>
<td align="center">支持的注解格式</td>
<td align="center">默认是SpringMVC的注解</td>
</tr>
<tr>
<td align="center">feign.Retryer</td>
<td align="center">失败重试机制</td>
<td align="center">请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td>
</tr>
</tbody></table>
<p>一般我们需要配置的是日志级别。</p>
<p><strong>配置日志级别有两种方式</strong></p>
<p><strong>方式一</strong>：配置文件方式</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment">#这里使用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">logger-level:</span> <span class="string">FULL</span> <span class="comment">#日志级别</span></span><br></pre></td></tr></table></figure></div>

<p><strong>方式二</strong>：Java代码的方式，需要先声明一个Bean：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignClientConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>之后如果是<strong>全局配置</strong>，则将它放到启动类上的注解<code>@EnableFeignClients</code>这个注解中：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class)</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>如果是<strong>局部配置</strong>，就将它放在需要使用feign发送请求的类的<code>@FeignClient</code>这个注解中：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value=&quot;userservice&quot;,configuration = FeignClientConfiguration.class)</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="5-3、Feign的性能优化"><a href="#5-3、Feign的性能优化" class="headerlink" title="5.3、Feign的性能优化"></a>5.3、Feign的性能优化</h3><p>Feign的客户端实现：</p>
<ul>
<li><strong>URLConnection</strong>：默认实现，不支持连接池</li>
<li><strong>Apache HttpClient</strong>：支持连接池</li>
<li><strong>OKHttp</strong>：支持连接池</li>
</ul>
<p><strong>因此优化Feign的性能主要包括：</strong></p>
<ol>
<li>使用连接池代替默认的URLConnection</li>
<li>日志级别，最好使用NONE或BASIC</li>
</ol>
<p><strong>Feign添加HttpClient的支持：</strong></p>
<ol>
<li><p>引入依赖：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>配置连接池</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment">#default全局的配置</span></span><br><span class="line">        <span class="attr">logger-level:</span> <span class="string">BASIC</span>   <span class="comment">#日志级别</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span>  <span class="comment">#最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment">#每个路径的最大连接数</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="5-4、Feign的最佳实践"><a href="#5-4、Feign的最佳实践" class="headerlink" title="5.4、Feign的最佳实践"></a>5.4、Feign的最佳实践</h3><p><strong>方式一（继承）</strong>：给消费者的FeignClient和提供者的Controller定义统一的父接口作为标准</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310141540417.png"
                      alt="image-20231014154049345"
                ></p>
<p><strong>方式二（抽取）</strong>：将FeignClient抽取为独立模块，并且将接口有关的POJO，默认的Feign配置都放到这个模块中，提供给所有消费者使用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310141540831.png"
                      alt="image-20231014154034652"
                ></p>
<blockquote>
<p>当使用方式二进行抽取的时候因为Feign不在SpringBoot项目启动类的目录下，所以无法扫描到Feign的包。</p>
<p>定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用。两种方式解决：</p>
<p><strong>方式一</strong>：指定FeignClient所在包</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;包的路径&quot;)</span></span><br></pre></td></tr></table></figure></div>

<p><strong>方式二</strong>：指定FeignClient的字节码【推荐】</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span></span><br></pre></td></tr></table></figure></div>


</blockquote>
<hr>

<h2 id="六、统一网关Gateway"><a href="#六、统一网关Gateway" class="headerlink" title="六、统一网关Gateway"></a>六、统一网关Gateway</h2><h3 id="6-1、了解网关"><a href="#6-1、了解网关" class="headerlink" title="6.1、了解网关"></a>6.1、了解网关</h3><p><strong>为什么需要网关？</strong></p>
<p>网关功能：</p>
<ul>
<li><strong>身份的验证和权限校验</strong></li>
<li><strong>服务路由、负载均衡</strong></li>
<li><strong>请求限流</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310150956010.png"
                      alt="image-20231015095626768"
                ></p>
<p><strong>网关的技术实现</strong></p>
<p>在SpringCloud中网关的实现包括两种：</p>
<ul>
<li>gateway</li>
<li>zuul</li>
</ul>
<p><code>Zuul</code>是基于<code>Servlet</code>的实现，属于<strong>阻塞式</strong>编程。而<code>SpringCloudGateway</code>则是基于Spring5中提供的<code>WebFlux</code>，属于<strong>响应式</strong>编程的实现，具有更好的性能</p>
<h3 id="6-2、搭建网关服务"><a href="#6-2、搭建网关服务" class="headerlink" title="6.2、搭建网关服务"></a>6.2、搭建网关服务</h3><ol>
<li><p>创建新的module，引入SpringCloudGateway的依赖和nacos的服务发现依赖：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网关gateway依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- nacos服务注册发现依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在配置文件<code>application.yml</code>文件中编写<strong>路由配置</strong>以及<strong>nacos地址</strong></p>
<p>路由配置包括：</p>
<ul>
<li>路由id：路由的唯一标识</li>
<li>路由目标（uri）：路由的目标地址，http标识固定地址，lb表示服务名负载均衡</li>
<li>路由断言（predicates）：判断路由的规则</li>
<li>路由过滤器（filters）：对请求和响应做处理</li>
</ul>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment">#网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment">#服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos 地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment">#网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment">#路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 #路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment">#路由的目标地址lb就是负载均衡【loadbalance】后面是服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment">#断言路由，也就是判断请求是否符合路由规格的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<blockquote>
<p><strong>小Tips：</strong></p>
<p>启动网关服务报错：<code>Consider defining a bean of type &#39;org.springframework.http.codec.ServerCodec</code><br>要排除其他依赖的spring-boot-starter-web，因为会与spring cloud gateway的webflux冲突。</p>
</blockquote>
<h4>网关执行过程</h4>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310151039170.png"
                      alt="image-20231015103913896"
                ></p>
<h3 id="6-3、路由断言工厂"><a href="#6-3、路由断言工厂" class="headerlink" title="6.3、路由断言工厂"></a>6.3、路由断言工厂</h3><p>网关路由可以配置的内容包括：</p>
<ul>
<li>路由id：路由的唯一标识</li>
<li>uri：路由的目的地，支持lb和http两种</li>
<li><strong style="color:red">predicates：路由断言，判断请求是否符合要求，符合则转发到路由目的地</strong></li>
<li>filters：路由过滤器，处理请求或响应</li>
</ul>
<p><strong>路由断言工厂Route Predicate Factory</strong></p>
<ul>
<li><p>在配置文件中书写的断言规则知只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p>
</li>
<li><p>例如Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由</p>
<p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来处理的</p>
</li>
<li><p>像这样的断言工厂在SpringCloudGateway还有多个</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">说明</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">After</td>
<td align="center">是某个时间点之后的请求</td>
<td align="center">官网查找</td>
</tr>
<tr>
<td align="center">Before</td>
<td align="center">是某个时间点之前的请求</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">Between</td>
<td align="center">是某两个时间点之前的请求</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">Cookie</td>
<td align="center">请求必须包含某些cookie</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">Header</td>
<td align="center">请求必须包含默写header</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">Method</td>
<td align="center">请求方式必须是指定方式</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">Path</td>
<td align="center">请求路径必须符合指定规则</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">Query</td>
<td align="center">请求参数必须包含指定参数</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">RemoteAddr</td>
<td align="center">请求者的ip必须是指定范围</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">Host</td>
<td align="center">请求必须是访问某个host（域名）</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">Weighe</td>
<td align="center">权重处理</td>
<td align="center">同上</td>
</tr>
</tbody></table>
<h3 id="6-4、路由过滤器"><a href="#6-4、路由过滤器" class="headerlink" title="6.4、路由过滤器"></a>6.4、路由过滤器</h3><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理</p>
<p>过滤器的作用：</p>
<ul>
<li>对路由的请求或响应做加工处理，比如添加请求头</li>
<li>配置在路由下的过滤器只对当前路由的请求生效</li>
<li>若想使用全局过滤器，则配置与gateway同级的defaultFilters，该过滤器对所有路由都生效</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310151131332.png"
                      alt="image-20231015111827722"
                ></p>
<h4>案例-给所有进入userservice的请求添加一个请求头</h4>

<p>给所有进入userservice的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!</p>
<p>实现方式：在gateway中修改application.yml文件，给userservice的路由添加过滤器</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment">#网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment">#服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos 地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment">#网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">          <span class="attr">predicates:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> </span><br><span class="line">		  <span class="attr">filters:</span> <span class="comment">#过滤器</span></span><br><span class="line">		  	<span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">talk</span> <span class="string">is</span> <span class="string">cheap</span> <span class="string">show</span> <span class="string">me</span> <span class="string">the</span> <span class="string">code!</span>	<span class="comment">#添加请求头</span></span><br></pre></td></tr></table></figure></div>

<p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">routes:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">      <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">      <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">lb://orderservice</span></span><br><span class="line">      <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br><span class="line"><span class="attr">default-filters:</span> <span class="comment">#默认过滤器，会对所有的路由请求都生效【与gateway同级】</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">talk</span> <span class="string">is</span> <span class="string">cheap</span> <span class="string">show</span> <span class="string">me</span> <span class="string">the</span> <span class="string">code!</span>	<span class="comment">#添加请求头</span></span><br></pre></td></tr></table></figure></div>





<h3 id="6-5、全局过滤器GlobalFilter"><a href="#6-5、全局过滤器GlobalFilter" class="headerlink" title="6.5、全局过滤器GlobalFilter"></a>6.5、全局过滤器GlobalFilter</h3><p>全局过滤器的作用是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用是一样的。</p>
<p>区别在于GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现。</p>
<p>定义方式是实现GlobalFilter接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 处理当前请求，有必要的话通过&#123;<span class="doctag">@Link</span> GatewayfilterChain&#125;将请求交给下一个过滤器处理</span></span><br><span class="line"><span class="comment">	* </span></span><br><span class="line"><span class="comment">	* <span class="doctag">@Param</span> 请求上下文。里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@Param</span> 用来把请求委托给下一个过滤器</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤业务结束</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>全局过滤器的作用是什么？</strong></p>
<p>对所有路由都生效的过滤器，并且可以自定义处理逻辑</p>
<p><strong>实现全局过滤器的步骤？</strong></p>
<ol>
<li>实现GlobalFilter接口</li>
<li>添加@Order注解或实现Ordered接口</li>
<li>编写处理逻辑</li>
</ol>
<p><strong>自定义全局过滤器的例子</strong>：实现GlobalFilter接口，添加@Order注解</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange,GatewayFilterChain chain)</span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取请求参数</span></span><br><span class="line">        MultiValueMap&lt;String,String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class="line">        <span class="comment">//2. 获取authorization 参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//3. 校验</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(auth))&#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4. 拦截</span></span><br><span class="line">        <span class="comment">//4.1 禁止访问</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">        <span class="comment">//4.2 结束处理</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h3 id="6-6、过滤器的执行顺序"><a href="#6-6、过滤器的执行顺序" class="headerlink" title="6.6、过滤器的执行顺序"></a>6.6、过滤器的执行顺序</h3><ul>
<li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong></li>
<li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li>
<li>路由过滤器和defaultFilter的order由spring指定，默认是按照声明顺序从1递增</li>
<li>当过滤器的order值一样时，会按照defaultFilter &gt; 局部路由过滤器 &gt; GlobalFilter的顺序执行</li>
</ul>
<h3 id="6-7、网关跨域问题"><a href="#6-7、网关跨域问题" class="headerlink" title="6.7、网关跨域问题"></a>6.7、网关跨域问题</h3><p>网关处理跨域采用的同样是CORS方案，并且只需要简单配置即可实现</p>
<p><strong>spring-framework从5.3.0版本开始，关于CORS跨域配置类</strong> <strong>CorsConfiguration</strong> <strong>中将 allowedOrigins 变量名修改为 allowedOriginPatterns</strong></p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span>	      <span class="comment"># 网关全局跨域配置</span></span><br><span class="line">		<span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment">#解决options请求被拦截的问题</span></span><br><span class="line">        <span class="attr">cors-configurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment">#允许哪些网站的跨域请求</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://www.leyou.com&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> 		<span class="comment">#允许跨域的ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;Delete&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span>		<span class="comment">#允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span>	<span class="comment">#是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span>		<span class="comment">#这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>常见技术问题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS抓包分析</title>
    <url>/2023/10/17/DNS%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、DNS概述"><a href="#一、DNS概述" class="headerlink" title="一、DNS概述"></a>一、DNS概述</h2><p>DNS（Domain Name System，域名系统）是互联网上是一种层次结构的基于域的命名方式和实现这种命名方式的分布式数据库，其中记录了<b style="color:red">各种主机域名与 IP 地址的对应关系</b>，能够使用户更加方便的访问网站。用户可以直接输入域名登录网站，DNS会将<b style="color:blue">域名解析成IP地址</b>，然后用户根据这个IP地址找到相应的网站，从而访问到域名对应的网站，通过主机名获取到主机名对应IP地址的过程叫作域名解析。</p>
<h2 id="二、DNS报文格式"><a href="#二、DNS报文格式" class="headerlink" title="二、DNS报文格式"></a>二、DNS报文格式</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310171205746.png"
                      alt="image-20231017120458631"
                ></p>
<h2 id="三、报文标志字段格式"><a href="#三、报文标志字段格式" class="headerlink" title="三、报文标志字段格式"></a>三、报文标志字段格式</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310171950379.png"
                      alt="image-20231017185950150"
                ></p>
<ul>
<li><strong>QR (Query&#x2F;Response)</strong>: 1位，标志查询或响应。当QR&#x3D;0时，表示这是一个查询报文；当QR&#x3D;1时，表示这是一个响应报文。</li>
<li><strong>Opcode (Operation Code)</strong>: 4位，标志DNS操作的类型。一些常见的值包括：<ol>
<li>0: 标准查询</li>
<li>1: 逆向查询</li>
<li>2: 服务器状态请求</li>
<li>4: 更新</li>
</ol>
</li>
<li><strong>AA (Authoritative Answer)</strong>: 1位，用于指示响应是否来自权威DNS服务器。如果AA&#x3D;1，表示响应来自权威服务器，否则为0。</li>
<li><strong>TC (Truncation)</strong>: 1位，指示报文是否被截断。如果TC&#x3D;1，表示报文太大而被截断。</li>
<li><strong>RD (Recursion Desired)</strong>: 1位，若为0则表示迭代查询，1位递归查询</li>
<li><strong>RA (Recursion Available)</strong>: 1位，表示DNS服务器是否支持递归查询。如果RA&#x3D;1，表示DNS服务器支持递归查询。</li>
<li><strong>Z (Reserved)</strong>: 3位，为将来的使用保留，通常设置为0</li>
<li><strong>RCODE (Response Code)</strong>: 4位，用于指示响应的状态。一些常见的响应代码包括：<ol>
<li>0: 没有错误</li>
<li>1: 格式错误</li>
<li>2: 服务器故障</li>
<li>3: 域名不存在</li>
<li>4: 查询类型不支持</li>
<li>5: 拒绝查询</li>
</ol>
</li>
</ul>
<h2 id="四、DNS的简略过程"><a href="#四、DNS的简略过程" class="headerlink" title="四、DNS的简略过程"></a>四、DNS的简略过程</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">发送一个查询包(query)</span><br><span class="line">接收一个回复包(response)</span><br></pre></td></tr></table></figure></div>



<h2 id="五、常见资源记录类型"><a href="#五、常见资源记录类型" class="headerlink" title="五、常见资源记录类型"></a>五、常见资源记录类型</h2><ul>
<li><strong>A 记录（Address Record）：</strong> 用于将主机名映射到IPv4地址。</li>
<li><strong>AAAA 记录（IPv6 Address Record）：</strong> 用于将主机名映射到IPv6地址。</li>
<li><strong>CNAME 记录（Canonical Name Record）：</strong> 用于创建别名，将一个域名指向另一个域名。</li>
<li><strong>TXT 记录（Text Record）：</strong> 用于存储文本信息，通常用于验证域名所有权和其他用途。</li>
<li><strong>SOA 记录（Start of Authority Record）：</strong> 用于指定域名的权威DNS服务器和其他参数</li>
<li><strong>NS 记录（Name Server Record）：</strong> 用于指定域名的权威DNS服务器。</li>
</ul>
<h2 id="六、抓包分析"><a href="#六、抓包分析" class="headerlink" title="六、抓包分析"></a>六、抓包分析</h2><p><b style="color:red">准备工作</b>【基于wireshark】</p>
<ol>
<li><p>在window系统打开控制台输入 <code>www.bloh.csdn.net</code></p>
</li>
<li><p>开启wirshark找到正在访问互联网的网卡，筛选DNS包，开始抓包</p>
<ul>
<li><p><strong>如何找到正在访问的网卡？</strong>首先打开网络和共享中心</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310171235456.png"
                      alt="image-20231017123516411"
                ></p>
</li>
<li><p>然后点击<b style="color:blue">连接</b>【此处是WLAN(SXXXNET)】，之后点击<b style="color:blue">详细信息</b></p>
<center class="half">
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310171235141.png"
                      width="550"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310171240746.png"
                      width="300"
                >
</center>
</li>
<li><p>然后就可以看到当前网卡详细的连接信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310171245786.png"
                      alt="image-20231017124510749"
                ></p>
</li>
</ul>
</li>
<li><p>继上述第二步发现自己网络连接的详细信息后看到wireshark页面，下面第一张图片的绿色区域选择DNS</p>
<ul>
<li><p>首先点击捕获并选择<strong>选项进行筛选</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310171247341.png"
                      alt="image-20231017124725302"
                ></p>
</li>
<li><p>找到对应的网络连接：点击开始即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310171951160.png"
                      alt="image-20231017125334227"
                ></p>
</li>
</ul>
</li>
<li><p>做好上述的工作之后cmd就可以ping <code> www.bloh.csdn.net</code>网址并捕获DNS包了，我们首先看到数据查询包（Query）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310171951968.png"
                      alt="image-20231017190849997"
                ></p>
<ul>
<li>可以看到资源记录类型为<code>A</code>，说明是IPV4的映射，是一个<code>query</code>查询报文</li>
<li>同时看到<code>port:53</code>说明运行端口在53，<code>RD=1</code>说明是递归查询</li>
</ul>
</li>
<li><p>看完上述的查询报文【query】，现在我们来分析分析回应报文【response】</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310171951337.png"
                      alt="image-20231017192543669"
                ></p>
<h3 id="6-1、标志字段详细分析"><a href="#6-1、标志字段详细分析" class="headerlink" title="6.1、标志字段详细分析"></a>6.1、标志字段详细分析</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310171951849.png"
                      alt="image-20231017192956661"
                ></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">Flags: <span class="number">0x8180</span> Standard query response, No error</span><br><span class="line">    <span class="number">1.</span>.. .... .... .... = Response: Message is a response							#QR字段</span><br><span class="line">    <span class="number">.000</span> <span class="number">0.</span>.. .... .... = Opcode: Standard <span class="built_in">query</span> (<span class="number">0</span>)								#Opcode字段</span><br><span class="line">    .... <span class="number">.0</span>.. .... .... = Authoritative: Server is <span class="keyword">not</span> an authority <span class="keyword">for</span> domain		#AA字段</span><br><span class="line">    .... .<span class="number">.0</span>. .... .... = Truncated: Message is <span class="keyword">not</span> truncated						#TC字段</span><br><span class="line">    .... ..<span class="number">.1</span> .... .... = Recursion desired: Do query recursively					#RD字段</span><br><span class="line">    .... .... <span class="number">1.</span>.. .... = Recursion available: Server can <span class="keyword">do</span> recursive queries		#RA字段</span><br><span class="line">    .... .... <span class="number">.0</span>.. .... = Z: <span class="built_in">reserved</span> (<span class="number">0</span>)											#Z保留字段</span><br><span class="line">    .... .... .<span class="number">.0</span>. .... = Answer authenticated: Answer/authority portion was <span class="keyword">not</span> authenticated by the server</span><br><span class="line">    .... .... ..<span class="number">.0</span> .... = Non-authenticated data: Unacceptable</span><br><span class="line">    .... .... .... <span class="number">0000</span> = Reply code: No <span class="built_in">error</span> (<span class="number">0</span>)									#rCode字段</span><br></pre></td></tr></table></figure></div>

<h3 id="6-2、问题部分"><a href="#6-2、问题部分" class="headerlink" title="6.2、问题部分"></a>6.2、问题部分</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310171951183.png"
                      alt="image-20231017193726199"
                ></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">Queries											#问题部分</span><br><span class="line">    www.blog.csdn.net: type A, <span class="keyword">class</span> <span class="title class_">IN</span>			</span><br><span class="line">        Name: www.blog.csdn.net					#查询名字段：这里是请求域名</span><br><span class="line">        [Name Length: <span class="number">17</span>]</span><br><span class="line">        [Label Count: <span class="number">4</span>]</span><br><span class="line">        Type: <span class="built_in">A</span> (<span class="number">1</span>) (Host Address)				#查询类型字段，这里为A类型</span><br><span class="line">        Class: <span class="built_in">IN</span> (<span class="number">0x0001</span>)						#查询类字段，这里为互连网地址</span><br></pre></td></tr></table></figure></div>



<h3 id="6-3、答案部分"><a href="#6-3、答案部分" class="headerlink" title="6.3、答案部分"></a>6.3、答案部分</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310171951551.png"
                      alt="image-20231017193945022"
                ></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">Answers									#回答区域字段</span><br><span class="line">    www.blog.csdn.net: type CNAME, <span class="keyword">class</span> <span class="title class_">IN</span>, cname <span class="number">3b</span>7c892a.csdn.net.cname.yunduns.com</span><br><span class="line">        Name: www.blog.csdn.net			#域名西段，这里是请求的域名：www.blog.csdn.net</span><br><span class="line">        Type: <span class="built_in">CNAME</span> (<span class="number">5</span>) (Canonical NAME <span class="keyword">for</span> an alias)			#类型字段：CNAME</span><br><span class="line">        Class: <span class="built_in">IN</span> (<span class="number">0x0001</span>)										#查询类字段：IN</span><br><span class="line">        Time to live: <span class="number">600</span> (<span class="number">10</span> minutes)							#生产时间TTL</span><br><span class="line">        Data length: <span class="number">37</span>											#数据长度</span><br><span class="line">        CNAME: <span class="number">3b</span>7c892a.csdn.net.cname.yunduns.com				#资源数据，此处为域名的规范跳转</span><br><span class="line">    <span class="number">3b</span>7c892a.csdn.net.cname.yunduns.com: type A, <span class="keyword">class</span> <span class="title class_">IN</span>, addr <span class="number">220.185</span><span class="number">.184</span><span class="number">.6</span></span><br><span class="line">        Name: <span class="number">3b</span>7c892a.csdn.net.cname.yunduns.com</span><br><span class="line">        Type: <span class="built_in">A</span> (<span class="number">1</span>) (Host Address)</span><br><span class="line">        Class: <span class="built_in">IN</span> (<span class="number">0x0001</span>)</span><br><span class="line">        Time to live: <span class="number">600</span> (<span class="number">10</span> minutes)</span><br><span class="line">        Data length: <span class="number">4</span></span><br><span class="line">        Address: <span class="number">220.185</span><span class="number">.184</span><span class="number">.6</span>									#资源数据：此处为IP地址</span><br></pre></td></tr></table></figure></div>



<h2 id="七、两种查询机制的分析"><a href="#七、两种查询机制的分析" class="headerlink" title="七、两种查询机制的分析"></a>七、两种查询机制的分析</h2><p><strong>1. 递归查询：</strong></p>
<ul>
<li><strong>工作过程：</strong><ul>
<li>客户端向本地DNS服务器发出DNS查询请求。</li>
<li>本地DNS服务器首先查看自己的缓存，如果有相应记录，直接返回。如果没有相应记录，它会向根DNS服务器发送查询请求</li>
<li>根DNS服务器返回一个指向顶级域名服务器的引导答案。</li>
<li>本地DNS服务器再向顶级域名服务器查询，然后一级一级地递归查询，直到找到所需的域名解析记录。最终的解析结果返回给客户端。</li>
</ul>
</li>
<li><strong>优点：</strong><ul>
<li>客户端只需向本地DNS服务器发送请求。</li>
<li>可以缓存解析结果，提高响应速度。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>增加了本地DNS服务器的负担，因为它必须执行多次迭代查询。</li>
<li>可能会导致网络拥塞，因为本地DNS服务器需要多次向其他DNS服务器发出查询请求。</li>
</ul>
</li>
</ul>
<p><strong>2. 迭代查询：</strong></p>
<ul>
<li><strong>工作过程：</strong><ul>
<li>客户端向本地DNS服务器发出DNS查询请求。</li>
<li>本地DNS服务器向根DNS服务器发送查询请求。</li>
<li>根DNS服务器返回一个指向顶级域名服务器的引导答案，但不执行递归查询。</li>
<li>本地DNS服务器再向顶级域名服务器查询，然后向下级域名服务器查询，直到找到所需的域名解析记录。</li>
<li>本地DNS服务器将中间的查询结果返回给客户端，客户端自行执行下一步查询。</li>
</ul>
</li>
<li><strong>优点：</strong><ul>
<li>减轻了本地DNS服务器的负担，因为它不需要执行多次递归查询。</li>
<li>减少了网络拥塞，因为每个DNS服务器只需执行一次查询并返回结果。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>对于客户端来说，需要更多的DNS查询步骤和处理。</li>
</ul>
</li>
</ul>
<p>当前的互联网环境更适合采用递归查询。避免客户端多次操作，减少理解DNS的1复杂性</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ基础</title>
    <url>/2023/10/22/MQ%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="一、MQ基础"><a href="#一、MQ基础" class="headerlink" title="一、MQ基础"></a>一、MQ基础</h2><h3 id="1-1、同步调用的优缺点"><a href="#1-1、同步调用的优缺点" class="headerlink" title="1.1、同步调用的优缺点"></a>1.1、同步调用的优缺点</h3><p>看到一个简单的业务实现：用户支付后，需要查询订单信息然后调用仓储服务…等一系列服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310211228604.png"
                      alt="image-20231021122832466"
                ></p>
<ul>
<li><strong>耦合度高</strong>：每次加入新的需求，都需要修改原来的代码。</li>
<li><strong>性能下降</strong>：调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用的时间之和。</li>
<li><strong>资源浪费</strong>：调用链中的每个服务在等待响应过程中不能释放请求占用的资源，高并发场景下极度浪费资源。</li>
<li><strong>级联失败</strong>：如果服务提供者出现问题，所有调用方都会跟着出现问题。</li>
</ul>
<blockquote>
<p><strong>优点</strong>：</p>
<p>同步调用虽然有以上的问题，但是相比于异步调用，同步服务的响应更迅速</p>
</blockquote>
<h3 id="1-2、异步调用的优缺点"><a href="#1-2、异步调用的优缺点" class="headerlink" title="1.2、异步调用的优缺点"></a>1.2、异步调用的优缺点</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310211236923.png"
                      alt="image-20231021123622858"
                ></p>
<ul>
<li><strong>耦合度降低</strong>：即增加新服务的时候只需要告知<b style="color:red">Broker【中间商】</b>添加订阅事件即可</li>
<li><strong>吞吐量提升</strong>：同步调用时，需要等待所有服务执行完用户才能得到响应，而异步调用用户向Broker发送请求后，无需等待全部服务的完成即可得到响应结果。</li>
<li><strong>故障隔离</strong>：服务之间没有强依赖关系，不担心级联失败问题。</li>
<li><strong>流量削峰</strong>：高并发请求通过Broker缓存，微服务基于服务能力从Broker中获取事件，处理事件，起到对微服务的保护作用</li>
</ul>
<blockquote>
<p><strong>缺点：</strong></p>
<ol>
<li>依赖于Broker的可靠性、安全性、吞吐能力</li>
<li>架构复杂，业务没有明显的流程线，不便于追踪管理</li>
</ol>
</blockquote>
<h3 id="1-3、什么是MQ"><a href="#1-3、什么是MQ" class="headerlink" title="1.3、什么是MQ"></a>1.3、什么是MQ</h3><p>MQ（MessageQueue）消息队列，也就是异步调用中的Broker</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RabbitMQ</th>
<th align="center">RockerMQ</th>
<th align="center">Kafka</th>
<th align="center">ActiveMQ</th>
</tr>
</thead>
<tbody><tr>
<td align="center">公司&#x2F;社区</td>
<td align="center">Rabbit</td>
<td align="center">阿里</td>
<td align="center">Apache</td>
<td align="center">Apache</td>
</tr>
<tr>
<td align="center">开发语言</td>
<td align="center">Erlang</td>
<td align="center">Java</td>
<td align="center">Scala&amp;Java</td>
<td align="center">Java</td>
</tr>
<tr>
<td align="center">协议支持</td>
<td align="center">AMQP、XMPP、SMTP、STOMP</td>
<td align="center">自定义协议</td>
<td align="center">自定义协议</td>
<td align="center">OpenWire、STOMP、REST、XMPP、AMQP</td>
</tr>
<tr>
<td align="center">可用性</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">一般</td>
</tr>
<tr>
<td align="center">单击吞吐量</td>
<td align="center">一般</td>
<td align="center">高</td>
<td align="center">非常高</td>
<td align="center">差</td>
</tr>
<tr>
<td align="center">消息延迟</td>
<td align="center">微妙级</td>
<td align="center">毫秒级</td>
<td align="center">毫秒以内</td>
<td align="center">毫秒级</td>
</tr>
<tr>
<td align="center">消息可靠性</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">一般</td>
<td align="center">一般</td>
</tr>
</tbody></table>
<hr>

<h2 id="二、RabbitMQ快速入门"><a href="#二、RabbitMQ快速入门" class="headerlink" title="二、RabbitMQ快速入门"></a>二、RabbitMQ快速入门</h2><h3 id="2-1、RabbitMQ部署【下载安装运行】"><a href="#2-1、RabbitMQ部署【下载安装运行】" class="headerlink" title="2.1、RabbitMQ部署【下载安装运行】"></a>2.1、RabbitMQ部署【下载安装运行】</h3><p><strong>当前ubuntu系统下使用docker下载镜像文件并运行MQ容器</strong></p>
<ol>
<li><p>运行docker</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>拉取MQ资源</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure></div>



<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310211418368.png"
                      alt="image-20231021141825306"  
                >
</li>
<li><p>执行以下命令配置并运行MQ容器</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310211427363.png"
                      alt="image-20231021142748304"
                ></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=root \			#此处设置用户名</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123456 \			#设置密码</span><br><span class="line"> --name mq \								#创建的容器名字</span><br><span class="line"> --hostname mq1 \							#设置端口名</span><br><span class="line"> -p 15672:15672 \							#设置管理端的端口</span><br><span class="line"> -p 5672:5672 \								#设置用户端的端口</span><br><span class="line"> -d \										#-d参数表示docker后台运行该容器</span><br><span class="line"> rabbitmq:3-management</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>上述配置成功实现后，我们打开RabbitMQ管理端页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310211436838.png"
                      alt="image-20231021143641785"
                ></p>
</li>
</ol>
<h3 id="2-2、RabbitMQ结构与概念"><a href="#2-2、RabbitMQ结构与概念" class="headerlink" title="2.2、RabbitMQ结构与概念"></a>2.2、RabbitMQ结构与概念</h3><p>打开MQ管理页面可以看到如下画面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310211440265.png"
                      alt="image-20231021144056228"
                ></p>
<p>页面中包含RabbitMQ的几个概念：</p>
<ul>
<li>Channel：操作MQ的工具</li>
<li>exchange：路由消息到队列中</li>
<li>queue：缓存消息</li>
<li>virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组</li>
</ul>
<p><strong>RabbitMQ的结构</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310211443471.png"
                      alt="image-20231021144325406"
                ></p>
<h3 id="2-3、RabbitMQ消息模型介绍"><a href="#2-3、RabbitMQ消息模型介绍" class="headerlink" title="2.3、RabbitMQ消息模型介绍"></a>2.3、RabbitMQ消息模型介绍</h3><p>MQ的官方文档给出了 6 个MQ的<a class="link"   href="https://rabbitmq.com/getstarted.html" >Demo示例 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，下面给出一些常用的用法：</p>
<ul>
<li>基本消息队列（BasicQueue）</li>
<li>工作消息队列（WorkQueue）</li>
<li>发布订阅（publish Subscribe），根据交换机类型不同分为三种：<ol>
<li><strong>Fanout Exchange</strong>：广播</li>
<li><strong>Direct Exchange</strong>：路由</li>
<li><strong>Topic Exchange</strong>：主题</li>
</ol>
</li>
</ul>
<h3 id="2-4、Helloworld案例"><a href="#2-4、Helloworld案例" class="headerlink" title="2.4、Helloworld案例"></a>2.4、Helloworld案例</h3><p>官方的Helloworld是基于最基础的消息队列模型来实现的，只包括三个角色：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310211501082.png"
                      alt="image-20231021150126050"
                ></p>
<ul>
<li>publisher：消息发布者，将消息发送到队列queue中</li>
<li>queue：消息队列，负责接收并缓存消息</li>
<li>consumer：订阅队列，处理队列中的信息</li>
</ul>
<p>打开idea创建两个模块，一个模块用来的当做消息发布者【publisher】，另一个模块用来当做消息接受者【comsumer】</p>
<p>并在这两个模块中添加RabbitMQ的依赖</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>然后在模块消息发布者中书写代码如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublisherTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.91.134&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接收模块书写接收消息队列的代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.91.134&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span><br><span class="line"><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>根据上述的Helloworld案例，可以知道<b style="color:red">基本消息队列</b>的消息发送流程：</p>
<ol>
<li>建立connection</li>
<li>创建channel</li>
<li>利用channel声明队列</li>
<li>利用channel向队列发送信息</li>
</ol>
<p>基本消息对立接收流程：</p>
<ol>
<li>建立connection</li>
<li>创建channel</li>
<li>利用channel声明队列</li>
<li>定义consumer的消费行为handleDelivery（）</li>
<li>利用channel将消费者与队列绑定</li>
</ol>
<hr>

<h2 id="三、SpringAMQP"><a href="#三、SpringAMQP" class="headerlink" title="三、SpringAMQP"></a>三、SpringAMQP</h2><ul>
<li>根据上文Helloworld案例使用<b style="color:blue">官方的API</b>实现的简单队列模型，可以发现使用官方的API操作十分麻烦，因此学习SpringAMQP，可以简化消息发送和接收的API</li>
</ul>
<p><strong>AMQP</strong>：Advanced Message Queuing Protocol ，是用于在应用程序或之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求</p>
<p><strong>SpringAMQP</strong>：是基于AMQP协议的一套API规范，提供了模板来发送和接收信息。包含两部分，其中spring-amqp是基础抽象，spring-rabbit是底层的默认实现</p>
<h3 id="3-1、案例：利用Spring-AMQP实现基础消息队列"><a href="#3-1、案例：利用Spring-AMQP实现基础消息队列" class="headerlink" title="3.1、案例：利用Spring-AMQP实现基础消息队列"></a>3.1、案例：利用Spring-AMQP实现基础消息队列</h3><h4 id="3-1-1、消息的发送"><a href="#3-1-1、消息的发送" class="headerlink" title="3.1.1、消息的发送"></a>3.1.1、消息的发送</h4><ol>
<li><p>在工程中添加<code>spring-amqp</code>的依赖</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在发布信息的模块中使用<code>RabbitTemplate</code>发送信息到<code>simple.queue</code>这个队列</p>
<ul>
<li><p>为了解除硬编码问题，首先编写配置文件<code>application.yml</code>添加MQ的连接信息</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.91</span><span class="number">.134</span>		<span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span>			<span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span>				<span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span>					<span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span>				<span class="comment"># 虚拟主机</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><a id="indexA"></a>编写一个测试类，测试发送信息到队列<code>simple.queue</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAMQPTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">messgae</span> <span class="operator">=</span> <span class="string">&quot;这是传递的信息&quot;</span>;【</span><br><span class="line">        rabbitTemplate.convertAndSend(queueName,messgae);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>启动程序并打开RabbitMQ管理端<code>http://192.168.91.134:15672</code>查看信息是否传递到队列</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222003439.png"
                      alt="image-20231021211000025"
                ></p>
</li>
<li><p>打开管理端查看队列可以看到确实缓存了一条信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222003736.png"
                      alt="image-20231022000737993"
                ></p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>注意事项</strong>：</p>
<p>操作工具类rabbitTemplate发送信息到队列的时候，需要先确保该队列已经存在，否则信息无法发送到队列，并且运行的时候也不会报错。</p>
<p><strong>声明队列的两种方法</strong>：</p>
<ol>
<li><p>在管理端图形界面手动创建队列</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222003400.png"
                      alt="image-20231021212614024"
                ></p>
</li>
<li><p>使用代码声明队列</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;sb.queue&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">messgae</span> <span class="operator">=</span> <span class="string">&quot;1231231&quot;</span>;</span><br><span class="line">	                     </span><br><span class="line">       <span class="comment">//声明队列</span></span><br><span class="line">       <span class="type">RabbitAdmin</span> <span class="variable">admin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RabbitAdmin</span>(rabbitTemplate);</span><br><span class="line">       <span class="type">Queue</span> <span class="variable">simpleQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(queueName);</span><br><span class="line">       admin.declareQueue(simpleQueue);</span><br><span class="line">       <span class="comment">//声明队列后向队列发送信息</span></span><br><span class="line">       rabbitTemplate.convertAndSend(queueName,messgae);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>此时打开管理端可以看到确实创建了一个新队列<code>sb.queue</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222003024.png"
                      alt="image-20231022000128634"
                ></p>
</li>
</ol>
</blockquote>
<p>其实综上所述，SpringAMQP发送信息无非以下几点</p>
<ol>
<li>引入amqp的starter依赖</li>
<li>配置RabbitMQ的地址</li>
<li>利用RabbitTemplate的<code>convertAndSend</code>方法</li>
</ol>
<h4 id="3-1-2、消息的接收"><a href="#3-1-2、消息的接收" class="headerlink" title="3.1.2、消息的接收"></a>3.1.2、消息的接收</h4><ol>
<li><p>在工程中添加<code>spring-amqp</code>的依赖【与上文发送消息步骤一致】</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建<code>application.yml</code>配置RabbitMQ的地址【与上文发送信息的步骤一致】</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.91</span><span class="number">.134</span>		<span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span>			<span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span>				<span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span>					<span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span>				<span class="comment"># 虚拟主机</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在接收信息的服务中新建一个类，编写处理信息的逻辑</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>			<span class="comment">//将该类声明为一个bean让spring能够发现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span>		<span class="comment">//该注解用来声明监听队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">workQueue</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring消费者接收到信息: &quot;</span> + msg + <span class="string">&quot;时间: &quot;</span> +LocalTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>运行并查看成功接收到- <a href="#indexA">上文发送的消息</a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222003097.png"
                      alt="image-20231022003803774"
                ></p>
</li>
<li><p>打开管理端查看队列，可以看到此时队列的信息被取走消息不存在了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222004475.png"
                      alt="image-20231022003945582"
                ></p>
</li>
</ol>
<p>综上所述，SpringAMQP接收消息为以下步骤：</p>
<ul>
<li>引入amqp的starter依赖</li>
<li>配置RabbitMQ地址</li>
<li>定义类，添加<code>@Component</code>注解，交给Spring管理</li>
<li>类中定义方法，添加<code>@RabbitListener</code>注解，方法参数就是接收的信息类型</li>
</ul>
<h3 id="3-2、WorkQueue模型"><a href="#3-2、WorkQueue模型" class="headerlink" title="3.2、WorkQueue模型"></a>3.2、WorkQueue模型</h3><p>基础消息队列：一个生产者对应一个消费者</p>
<p>工作队列：一个生产者对应多个消费者，多个消费者绑定到同一个队列，同一条消息只会被一个消费者处理</p>
<ul>
<li>提高消息的处理速度，避免队列消息堆积</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222004896.png"
                      alt="image-20231022103055621"
                ></p>
<h4 id="3-2-1、模拟workqueue"><a href="#3-2-1、模拟workqueue" class="headerlink" title="3.2.1、模拟workqueue"></a>3.2.1、模拟workqueue</h4><ul>
<li><strong>实现一个队列绑定多个消费者</strong></li>
</ul>
<p>	</p>
<p>基本思路如下：</p>
<ol>
<li>在publisher服务中定义测试方法，每秒产生50条信息，发送到<code>simple.queue</code></li>
<li>在consumer服务中定义两个消息监听者，都监听<code>simple.queue</code>队列</li>
<li>消费者(1)每秒处理50条信息，消费者(2)每秒处理10条信息</li>
<li></li>
</ol>
<p>案例实现：</p>
<ul>
<li><p><strong>首先定义生产者，每秒发送五十条信息</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAMQPTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendToWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;工作队列测试信息__&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++)&#123;</span><br><span class="line">            rabbitTemplate.convertAndSend(queueName,message+i);</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222004411.png"
                      alt="image-20231022104842073"
                ></p>
</li>
<li><p><strong>然后定义两个消费者监听相同的队列</strong><code>simple.queue</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">workQueue_1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者(1)接收: 【&quot;</span> + msg + <span class="string">&quot;】时间: &quot;</span> +LocalTime.now());</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);		<span class="comment">//此处调节线程睡眠时间的不同，从而实现控制处理性能的高低</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">workQueue_2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;消费者(2)接收: 【&quot;</span> + msg + <span class="string">&quot;】时间: &quot;</span> +LocalTime.now());</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);		<span class="comment">//此处调节线程睡眠时间的不同，从而实现控制处理性能的高低</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222004496.png"
                      alt="image-20231022105036440"
                ></p>
<ul>
<li><strong>启动生产者服务，向队列发送五十条信息，然后启动消费者服务可以看到消息平均分配给两个消费者</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222004613.png"
                      alt="image-20231022110111276"
                ></p>
</li>
</ul>
<p><strong>平均分配是为什么呢？</strong></p>
<ul>
<li>因为没有配置RabbitMQ的消息预取机制，因此每个消费者取信息的能力是无限的，因此上述案例中的两个消费者平均取走了消息，即使二者就算存在了处理性能的差异，因为取走信息的数量是相同的，因此最后处理的数据还是等量的。</li>
</ul>
<p><strong>如果消费者都是平均分配信息处理，那就没有考虑到每个消费者的性能。</strong></p>
<ul>
<li>我们希望处理性能高的消费者处理多点信息，处理性能低的消费者少处理点信息，那么总的处理时间就可以大大降低了。</li>
</ul>
<p><strong>因此需要配置消息预取的数量，这样便可以控制处理越快的消费者获取的消息就越多</strong></p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.91</span><span class="number">.134</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span>				<span class="comment"># 消息预取数量控制</span></span><br></pre></td></tr></table></figure></div>

<p><strong>然后我们重启生产者和消费者服务，再次查看处理信息的情况</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222004787.png"
                      alt="image-20231022113412980"
                ></p>
<h3 id="3-3、发布订阅模型"><a href="#3-3、发布订阅模型" class="headerlink" title="3.3、发布订阅模型"></a>3.3、发布订阅模型</h3><p>前面介绍的案例都是只能实现一条消息一个消费者接收并使用</p>
<p>而发布订阅模型与它们的区别就是允许将同一条消息发送给多个消费者。实现方式是加入了Exchange（交换机）</p>
<p>常见的交换机类型包括：</p>
<ul>
<li>Fanout：广播</li>
<li>Direct：路由</li>
<li>Topic：话题</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222004254.png"
                      alt="image-20231022114425190"
                ></p>
<blockquote>
<p><b style="color:red">注意</b>：exchange只负责消息路由，不是存储，路由失败则消息丢失</p>
</blockquote>
<h4 id="3-3-1、Fanout-Exchange"><a href="#3-3-1、Fanout-Exchange" class="headerlink" title="3.3.1、Fanout_Exchange"></a>3.3.1、Fanout_Exchange</h4><p>Fanout Exchange会将接收到的消息路由到每一个跟其绑定的queue</p>
<p><strong>利用SpringAMQP演示Fanoutexchange的使用</strong></p>
<p>实现思路如下：</p>
<ol>
<li>在消费者服务中，利用代码声明队列、交换机、并将二者绑定</li>
<li>在消费者服务中，编写两个消费者方法，分别监听fanout.queue(1)和fanout.queue(2)</li>
<li>在生产者中编写测试方法，向itcast.fanout发送信息</li>
</ol>
<p><strong>步骤一：</strong>在consumer服务<a id="indexB"></a><span style="color:red">使用bean声明Exchange、Queue、Binding</span></p>
<p>在Consumer服务常见的一个类，添加@Configuration注解，并声明FanoutExchange、Queue和绑定关系对象Binding，代码如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">//声明一个Fanout交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;mystudy.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue_1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定队列和交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue</span><span class="params">(Queue fanoutQueue_1,FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">            .bind(fanoutQueue_1)</span><br><span class="line">            .to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//..相同方式声明第二个队列，并完成绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue_2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue_2,FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">            .bind(fanoutQueue_1)</span><br><span class="line">            .to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>启动服务后，打开MQ管理端查看是否成功绑定了交换机与队列的关系</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222004793.png"
                      alt="image-20231022144702393"
                ></p>
<p><strong>步骤二</strong>：队列与交换机绑定关系成功后，<strong>在consumer服务中定义监听函数，监听两个队列</strong></p>
<p><strong>步骤三</strong>：<strong>并在publisher中发送信息到交换机</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222005919.png"
                      alt="image-20231022145924938"
                ></p>
<p>启动服务可以看到两个队列都收到了消息：<strong>可知交换机将一条消息发给了绑定关系的两个队列</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222005495.png"
                      alt="image-20231022150012898"
                ><strong>综上所述：交换机的作用是什么？</strong></p>
<ul>
<li>接收发布的消息</li>
<li>将消息按照规则路由到与之绑定的队列</li>
<li>不能缓存消息，路由失败，信息丢失</li>
<li>FanoutExchange会将消息路由到每个绑定的队列</li>
</ul>
<p><strong>声明队列、交换机、绑定关系的Bean是什么？</strong></p>
<ul>
<li><code>Queue</code></li>
<li><code>FanoutExchange</code></li>
<li><code>Binding</code></li>
</ul>
<h4 id="3-3-2、Direct-Exchange"><a href="#3-3-2、Direct-Exchange" class="headerlink" title="3.3.2、Direct_Exchange"></a>3.3.2、Direct_Exchange</h4><p>Direct Exchange会将接收到的信息根据规则路由到指定的Queue，因此称为路由模式（routes）。</p>
<ul>
<li>每一个Queue都与Exchange设置一个BindingKey</li>
<li>发布者发送消息时，指定消息的RoutingKey</li>
<li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222005395.png"
                      alt="image-20231022152327701"
                ></p>
<p><strong>利用SpringAMQP演示DirectExchange的使用</strong></p>
<p>实现思路如下：</p>
<ol>
<li><p>利用注解<code>@RabbitListener</code>声明Exchange、Queue、RoutingKey【原来的使用bean来配置Exchange、Queue、RoutingKey太复杂，因此直接在注解中声明即可】-<a href="#indexB">点击查看使用bean配置的例子</a></p>
</li>
<li><p>在consumer服务中，编写两个消费者方法，分别监听<code>direct.queue1</code>和<code>direct.queue2</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">	value = @Queue(name=&quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">	exchange = @Exchange(name = &quot;mystudy.direct&quot;,type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">	key = &#123;&quot;red&quot;,&quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirect_1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;接收到direct.queue_1的信息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">	value = @Queue(name=&quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">	exchange = @Exchange(name = &quot;mystudy.direct&quot;,type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">	key = &#123;&quot;red&quot;,&quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirect_2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;接收到direct.queue_2的信息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222005382.png"
                      alt="image-20231022155509942"
                ></p>
<p><strong>启动服务查看交换机的配置详情</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222006505.png"
                      alt="image-20231022155944510"
                ></p>
</li>
<li><p>在publisher中编写测试方法，向<code>mystudy.direct</code>发送信息，启动服务观察结果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222005190.png"
                      alt="image-20231022160845453"
                ></p>
<p>因此可以验证：<strong>Direct_Exchange将消息路由到BindingKey与消息RoutingKey一致的队列</strong></p>
</li>
</ol>
<blockquote>
<p><strong>Direct交换机和Fanout交换机的差异？</strong></p>
<ul>
<li>Fanout交换机将消息路由给每一个与之绑定的队列</li>
<li>Direct交换机根据RoutingKey判断路由给哪一个队列</li>
<li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li>
</ul>
<p><strong>基于注解@RabbitListener注解声明队列和交换机有哪些常见注解</strong></p>
<ul>
<li>@Queue</li>
<li>@Exchange</li>
</ul>
</blockquote>
<h4 id="3-3-3、Topic-Exchange"><a href="#3-3-3、Topic-Exchange" class="headerlink" title="3.3.3、Topic_Exchange"></a>3.3.3、Topic_Exchange</h4><p>TopicExchange和DirectExchange类似，区别在于routintKey必须是多个单词的列表，并且以<code>.</code>分割</p>
<p>Queue与Exchange指定BindingKey时可以使用通配符：</p>
<p><code>#</code>：指代0个或多个单词</p>
<p><code>*</code>：指代一个单词</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222005596.png"
                      alt="image-20231022164636256"
                ></p>
<p><strong>利用SpringAMQP演示TopicExchange的使用</strong></p>
<p>实现思路如下：</p>
<ol>
<li><p>利用<code>@RabbitListener</code>声明Exchange、Queue、RoutingKey</p>
</li>
<li><p>在Consumer服务中，编写两个消费者方法，分别监听<code>topic.queue1</code>和<code>topic.queue2</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name=&quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;mystudy.topic&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">        key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopic_1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到topic.queue_1的信息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name=&quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;mystudy.topic&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">        key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopic_2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到topic.queue_2的信息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在publisher中编写测试方法，向<code>mystudy.topic</code>发送信息 </p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendTo_China_News</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;mystudy.topic&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;交换机topic测试信息__&#123;China and News&#125;__&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;china.news&quot;</span>;</span><br><span class="line">	rabbitTemplate.convertAndSend(exchangeName,routingKey,msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendTo_News</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;mystudy.topic&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;交换机topic测试信息__&#123;China and News&#125;__&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;test.news&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,routingKey,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="3-4、消息转换器"><a href="#3-4、消息转换器" class="headerlink" title="3.4、消息转换器"></a>3.4、消息转换器</h3><p>说明：<strong>在SpringAMQP的发送方法中，接收信息的类型是Object，也就是说我们可以发送任意对象类型的消息，SpringAMQP会帮我们序列化为字节后发送。</strong></p>
<p>验证：查看RabbitTempate的<code>convertAndSend</code>函数接收的参数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222005540.png"
                      alt="image-20231022170400657"
                ></p>
<p><strong>查看原来的消息转换器接收对象之后的处理结果，然后在使用新的转换器</strong></p>
<p><strong>第一步</strong>：定义一个新的队列用来接收对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">objectQueue</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;object.queue&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>第二步</strong>：编写发送信息的函数</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendToObjQueue</span><span class="params">()</span>&#123;</span><br><span class="line">	Map&lt;String, Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	msg.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	msg.put(<span class="string">&quot;age&quot;</span>,<span class="number">21</span>);</span><br><span class="line">	rabbitTemplate.convertAndSend(<span class="string">&quot;object.queue&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>第三步</strong>：打开管理端查看存储的内容可以看到存储的内容是<strong>Java序列化的对象</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222005530.png"
                      alt="image-20231022185832721"
                ></p>
<p>Spring的对消息的处理是由org.springframework.amqp.support.converter.MessageConverter来处理的。而默认实现是SimpleMessageConverter，基于JDK的ObjectOupytStream完成序列化。</p>
<p>如果要修改只需要定义一个MessageConverter类型的bean即可。推荐使用JSON方式序列化，步骤如下：</p>
<ul>
<li><p>首先在publisher服务中引入依赖</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在publisher服务声明MessageConverter</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>上述配置完成后重新发送对象信息，再次打开管理端查看存储的内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310222006112.png"
                      alt="image-20231022194007063"
                ></p>
</li>
<li><p>上述就已经完成了对发送消息时候的格式转换，接收消息的时候同样需要进行消息的转换，因此引入依赖，配置转换器两部的操作是一致的。</p>
</li>
<li><p>首先在consumer服务中引入依赖</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在consumer服务声明MessageConverter</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>综上所述：SpringAMQP中消息的序列化和反序列化是如何实现的？</p>
<ul>
<li>利用MessageConverter实现的，默认是<code>JDK的序列化</code></li>
<li>注意发送方与接收方必须使用<strong>相同</strong>的<code>MessageConverter</code></li>
</ul>
]]></content>
      <categories>
        <category>常见技术问题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch</title>
    <url>/2023/10/25/ES/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><strong>什么是elasticsearch？</strong></p>
<ul>
<li>一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能</li>
</ul>
<p><strong>什么是elastic stack（ELK）？</strong></p>
<ul>
<li>是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch</li>
</ul>
<p><strong>什么是Lucene？</strong></p>
<ul>
<li>Apache的开源搜索引擎，提供了搜索引擎的核心API</li>
</ul>
<h2 id="二、正向索引和倒排索引"><a href="#二、正向索引和倒排索引" class="headerlink" title="二、正向索引和倒排索引"></a>二、正向索引和倒排索引</h2><ul>
<li>传统数据库（如MYSQL）采用正向索引，而elasticsearch采用倒排索引</li>
<li><strong>什么是文档和词条？</strong><ol>
<li>每一条数据就是一个文档</li>
<li>对文档中的内容分词，得到的词语就是词条</li>
</ol>
</li>
<li><strong>什么是正向索引？</strong>基于文档id创建索引。查询词条时必须先找到文档，然后判断是否包含词条</li>
<li><strong>什么是倒排索引？</strong>对文档内容分词，对词条创建索引，并记录词条所在文档的信息。查询时先根据词条查询到文档id，而后获取到文档</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310251120425.png"
                      alt="image-20231024094220052"
                ></p>
<h2 id="三、elasticsearch与MySQL的概念对比"><a href="#三、elasticsearch与MySQL的概念对比" class="headerlink" title="三、elasticsearch与MySQL的概念对比"></a>三、elasticsearch与MySQL的概念对比</h2><p>elasticsearch是面向文档存储的，可以是数据库中的一条商品数据，一个订单信息。</p>
<p>文档数据会被<b style="color:red">序列化为json格式后存储在elasticsearch中</b></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310251120426.png"
                      alt="image-20231024162740760"
                ></p>
<p><strong>索引</strong></p>
<ul>
<li>索引（index）：相同类型的文档的集合</li>
<li>映射（mapping）：索引中文档的字段约束信息，类似表的结构约束</li>
</ul>
<table>
<thead>
<tr>
<th align="center">MYSQL</th>
<th align="center">Elasticsearch</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Table</td>
<td align="center">Index</td>
<td align="center">索引（index），就是文档的集合，类似数据库的表（table）</td>
</tr>
<tr>
<td align="center">Row</td>
<td align="center">Document</td>
<td align="center">文档（Document），一条条的数据，类似数据库中的行（Row）文档就是JSON格式</td>
</tr>
<tr>
<td align="center">Column</td>
<td align="center">Field</td>
<td align="center">字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td>
</tr>
<tr>
<td align="center">Schema</td>
<td align="center">Mapping</td>
<td align="center">Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构</td>
</tr>
<tr>
<td align="center">SQL</td>
<td align="center">DSL</td>
<td align="center">DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CURD</td>
</tr>
</tbody></table>
<p><strong>架构</strong></p>
<p>MYSQL：擅长事务类型操作，可以确保数据的安全和一致性</p>
<p>Elasticsearch：擅长海量数据的搜索、分析、计算</p>
<h2 id="四、部署elasticsearch和kibana"><a href="#四、部署elasticsearch和kibana" class="headerlink" title="四、部署elasticsearch和kibana"></a>四、部署elasticsearch和kibana</h2><p><strong>部署基于Docker</strong></p>
<p><strong>kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习</strong></p>
<h3 id="4-1、创建网络"><a href="#4-1、创建网络" class="headerlink" title="4.1、创建网络"></a>4.1、创建网络</h3><p>首先需要创建一个docker网络用于elasticsearch与kibana互连</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create es-net</span><br></pre></td></tr></table></figure></div>

<h3 id="4-2、拉取elasticsearch和kibana的镜像"><a href="#4-2、拉取elasticsearch和kibana的镜像" class="headerlink" title="4.2、拉取elasticsearch和kibana的镜像"></a>4.2、拉取elasticsearch和kibana的镜像</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch:7.12.1	 # elasticsearch镜像地址</span><br><span class="line">docker pull docker.elastic.co/kibana/kibana:7.12.1					 # kibana镜像地址</span><br></pre></td></tr></table></figure></div>



<h3 id="4-3、运行ES"><a href="#4-3、运行ES" class="headerlink" title="4.3、运行ES"></a>4.3、运行ES</h3><p>运行docker命令，部署elasticsearch</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">	--name es \</span><br><span class="line">    -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \</span><br><span class="line">    -e &quot;discovery.type=single-node&quot; \</span><br><span class="line">    -v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">    -v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">    --privileged \</span><br><span class="line">    --network es-net \</span><br><span class="line">    -p 9200:9200 \</span><br><span class="line">    -p 9300:9300 \</span><br><span class="line">elasticsearch:7.12.1</span><br></pre></td></tr></table></figure></div>

<p>命令解释：</p>
<ul>
<li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li>
<li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li>
<li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li>
<li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li>
<li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li>
<li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li>
<li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li>
<li><code>--privileged</code>：授予逻辑卷访问权</li>
<li><code>--network es-net</code> ：加入一个名为es-net的网络中</li>
<li><code>-p 9200:9200</code>：端口映射配置</li>
</ul>
<p>在浏览器中输入：<a class="link"   href="http://192.168.91.134:9200/" >http://192.168.91.134:9200 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 即可看到elasticsearch的响应结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310251120427.png"
                      alt="image-20231024162438212"
                ></p>
<h3 id="4-4、运行Kibana"><a href="#4-4、运行Kibana" class="headerlink" title="4.4、运行Kibana"></a>4.4、运行Kibana</h3><p>运行docker命令，部署kibana</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span><br><span class="line">--network=es-net \</span><br><span class="line">-p 5601:5601  \</span><br><span class="line">kibana:7.12.1</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>--network es-net</code> ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li>
<li><code>-e ELASTICSEARCH_HOSTS=http://es:9200&quot;</code>：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</li>
<li><code>-p 5601:5601</code>：端口映射配置</li>
</ul>
<p>kibana启动一般比较慢，需要多等待一会，可以通过命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f kibana</span><br></pre></td></tr></table></figure></div>

<p>查看当前运行日志，当看到下述日志说明运行成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310251120428.png"
                      alt="image-20231024162527201"
                ></p>
<p>此时，在浏览器输入地址访问：<a href="http://192.168.91.134:5601，即可看到结果">http://192.168.91.134:5601，即可看到结果</a></p>
<h3 id="4-5、DevTools"><a href="#4-5、DevTools" class="headerlink" title="4.5、DevTools"></a>4.5、DevTools</h3><p>kibana中提供了一个DevTools界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310251120429.png"
                      alt="image-20231024162320232"
                ></p>
<p>这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。</p>
<h2 id="五、安装IK分词器"><a href="#五、安装IK分词器" class="headerlink" title="五、安装IK分词器"></a>五、安装IK分词器</h2><h3 id="5-1、在线安装ik插件"><a href="#5-1、在线安装ik插件" class="headerlink" title="5.1、在线安装ik插件"></a>5.1、在线安装ik插件</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器内部</span></span><br><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在线下载并安装</span></span><br><span class="line">./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">退出</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure></div>



<h3 id="5-2、扩展词词典"><a href="#5-2、扩展词词典" class="headerlink" title="5.2、扩展词词典"></a>5.2、扩展词词典</h3><p>随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。所以词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。</p>
<p>1）打开IK分词器config目录：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310251120431.png"
                      alt="image-20231024163129936"
                ></p>
<p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">示例</span></span><br><span class="line"><span class="attr">洛克王国</span></span><br></pre></td></tr></table></figure></div>

<p>4）重启elasticsearch </p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">docker restart es</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 日志</span></span><br><span class="line">docker logs -f elasticsearch</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310251120432.png"
                      alt="image-20231024163411760"
                ></p>
<p>日志中已经成功加载ext.dic配置文件</p>
<p>5）测试效果：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;洛克王国测试示例&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p>
</blockquote>
<h3 id="5-3、停用词词典"><a href="#5-3、停用词词典" class="headerlink" title="5.3、停用词词典"></a>5.3、停用词词典</h3><p>在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。</p>
<p>IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。</p>
<p>1）IKAnalyzer.cfg.xml配置文件内容添加：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span>stopword.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>3）在 stopword.dic 添加停用词</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">沙比</span></span><br></pre></td></tr></table></figure></div>

<p>4）重启elasticsearch </p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">docker restart elasticsearch</span><br><span class="line">docker restart kibana</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 日志</span></span><br><span class="line">docker logs -f elasticsearch</span><br></pre></td></tr></table></figure></div>

<p>日志中已经成功加载stopword.dic配置文件</p>
<p>5）测试效果：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;洛克王国测试示例沙比&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p>
</blockquote>
<h2 id="六、索引库操作"><a href="#六、索引库操作" class="headerlink" title="六、索引库操作"></a>六、索引库操作</h2><h3 id="6-1、mapping属性"><a href="#6-1、mapping属性" class="headerlink" title="6.1、mapping属性"></a>6.1、mapping属性</h3><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p>
<ul>
<li><code>type</code>：字段数据类型，常见的简单类型有：<ul>
<li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li>
<li>数值：long、integer、short、byte、double、float</li>
<li>布尔：boolean</li>
<li>日期：date</li>
<li>对象：object</li>
</ul>
</li>
<li><code>index</code>：是否创建索引，默认为true</li>
<li><code>analyzer</code>：使用哪种分词器</li>
<li><code>properties</code>：该字段的子字段</li>
</ul>
<h3 id="6-2、创建索引库"><a href="#6-2、创建索引库" class="headerlink" title="6.2、创建索引库"></a>6.2、创建索引库</h3><p>ES中通过Restful请求操作索引库、文档。请求内容用DSL语句来表示。创建索引库和mapping的DSL语法如下：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">PUT /kucun</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;类型&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段3&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;子字段&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;keyword&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>



<h3 id="6-3、查看、删除索引库"><a href="#6-3、查看、删除索引库" class="headerlink" title="6.3、查看、删除索引库"></a>6.3、查看、删除索引库</h3><ul>
<li><strong>查询索引库语法</strong>：</li>
</ul>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>删除索引库语法</strong>：</li>
</ul>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>修改索引库语法</strong>：</li>
</ul>
<p>索引库和mapping一旦创建无法修改，但是可以添加新的字段</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;新字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;integer&quot;</span>k</span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="6-4、新增、插叙、删除、修改文档"><a href="#6-4、新增、插叙、删除、修改文档" class="headerlink" title="6.4、新增、插叙、删除、修改文档"></a>6.4、新增、插叙、删除、修改文档</h3><ul>
<li><strong>新增文档语法</strong>：</li>
</ul>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段名1&quot;</span><span class="punctuation">:</span><span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段名2&quot;</span><span class="punctuation">:</span><span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段名3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;子属性1&quot;</span><span class="punctuation">:</span><span class="string">&quot;值3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;子属性2&quot;</span><span class="punctuation">:</span><span class="string">&quot;值4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>查询文档语法</strong>：</li>
</ul>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_doc/文档id</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>删除文档语法</strong>：</li>
</ul>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /索引库名/_doc/文档id</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>修改文档</strong></li>
</ul>
<p><strong>方式一</strong>：全量修改，会删除文档，添加新文档</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段名1&quot;</span><span class="punctuation">:</span><span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段名2&quot;</span><span class="punctuation">:</span><span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>方式二</strong>：增量修改，修改指定字段值</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_update/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span><span class="string">&quot;新的值&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>



<p><strong>总结</strong>：文档操作</p>
<ul>
<li><strong>创建文档</strong>：POST &#x2F;索引库名&#x2F;_doc&#x2F;文档id {JSON文档}</li>
<li><strong>查询文档</strong>：GET &#x2F;索引库名&#x2F;_doc&#x2F;文档id</li>
<li><strong>删除文档</strong>：DELETE 索引库名&#x2F;_doc&#x2F;文档id</li>
<li><strong>修改文档</strong>：<ul>
<li><strong>全量修改</strong>：PUT &#x2F;索引库名&#x2F;_doc&#x2F;文档id {JSON文档}</li>
<li><strong>增量修改</strong>：POST &#x2F;索引库名&#x2F;_update&#x2F;文档id {“doc”:{字段}}</li>
</ul>
</li>
</ul>
<h2 id="七、RestClient操作索引库"><a href="#七、RestClient操作索引库" class="headerlink" title="七、RestClient操作索引库"></a>七、RestClient操作索引库</h2><p><strong>什么是RestClient</strong></p>
<p>ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。</p>
<h3 id="7-1、初始化JavaRestClient"><a href="#7-1、初始化JavaRestClient" class="headerlink" title="7.1、初始化JavaRestClient"></a>7.1、初始化JavaRestClient</h3><ol>
<li><p>引入es的RestHighLevelClient依赖：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>导入了依赖我们打开Maven查看一下导入的ES版本会发现有两项ES是7.6.2版本的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310251120433.png"
                      alt="image-20231024205348553"
                ></p>
</li>
<li><p>因为SpringBoot的默认ES版本为7.6.2因此需要覆盖默认的ES版本</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310251120434.png"
                      alt="image-20231024205636441"
                ></p>
</li>
<li><p>初始化RestHighLevelClient</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">	HttpHost.create(<span class="string">&quot;http://192.168.91.134:9200&quot;</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="7-2、创建索引库"><a href="#7-2、创建索引库" class="headerlink" title="7.2、创建索引库"></a>7.2、创建索引库</h3><ul>
<li>创建索引库代码示例</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create_index</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">// 1.创建Request对象</span></span><br><span class="line">	<span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">	<span class="comment">// 2.请求参数, MAPPING_TEMPLATE是静态常量字符串，内容是创建索引库的DSL语句</span></span><br><span class="line">	request.source(MAPPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">	<span class="comment">// 3.发起请求</span></span><br><span class="line">	client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310251120435.png"
                      alt="image-20231025004129827"
                ></p>
<h3 id="7-3、删除、判断索引库是否存在"><a href="#7-3、删除、判断索引库是否存在" class="headerlink" title="7.3、删除、判断索引库是否存在"></a>7.3、删除、判断索引库是否存在</h3><ul>
<li>删除索引库代码示例</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del_index</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">//1. 创建Request对象</span></span><br><span class="line">	<span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">	<span class="comment">//2. 发起请求</span></span><br><span class="line">	client.indices().delete(request,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<ul>
<li>判断索引库是否存在</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isExist_index</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">// 1. 创建Request对象</span></span><br><span class="line">	<span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">	<span class="comment">// 2. 发起请求</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">	<span class="comment">// 3. 输出</span></span><br><span class="line">	System.out.println(exists == <span class="literal">true</span> ? <span class="string">&quot;索引已存在&quot;</span>:<span class="string">&quot;索引不存在&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h3 id="7-4、新增文档"><a href="#7-4、新增文档" class="headerlink" title="7.4、新增文档"></a>7.4、新增文档</h3><ul>
<li>新增文档代码示例</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310251120436.png"
                      alt="image-20231025100017815"
                ></p>
<h3 id="7-5、查询文档"><a href="#7-5、查询文档" class="headerlink" title="7.5、	查询文档"></a>7.5、	查询文档</h3><ul>
<li>查询文档代码示例</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310251120437.png"
                      alt="image-20231025101106164"
                ></p>
<h3 id="7-6、修改文档"><a href="#7-6、修改文档" class="headerlink" title="7.6、修改文档"></a>7.6、修改文档</h3><p>修改文档数据有两种方式：</p>
<p>方式一：全量更新。再次写入一个id一样的文档，就会删除旧文档，创建新文档</p>
<p>方式二：局部更新。只更新部分字段</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://web-mybatis.oss-cn-beijing.aliyuncs.com/typora_picture/202310251120438.png"
                      alt="image-20231025104500089"
                ></p>
<h3 id="7-7、删除文档"><a href="#7-7、删除文档" class="headerlink" title="7.7、删除文档"></a>7.7、删除文档</h3><ul>
<li>删除文档代码示例</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;hotel&quot;</span>,<span class="string">&quot;61083&quot;</span>);<span class="comment">//参数：索引库，文档id</span></span><br><span class="line">	client.delete(request,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<p><strong>文档操作的基本步骤</strong></p>
<ul>
<li>初始化<code>RestHighLevelClient</code></li>
<li>创建 ___Request。___是Index、Get、Update、Delete</li>
<li>准备参数（Index和Update时需要）</li>
<li>发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete</li>
<li>解析结果（Get时需要）</li>
</ul>
<h3 id="7-8、批量添加文档"><a href="#7-8、批量添加文档" class="headerlink" title="7.8、批量添加文档"></a>7.8、批量添加文档</h3><ul>
<li>代码示例</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAllDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">//将数据库中所有的数据查询出来</span></span><br><span class="line">	List&lt;Hotel&gt; hotels = hotelService.list();</span><br><span class="line">	<span class="comment">// 1.创建request</span></span><br><span class="line">	<span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">	<span class="keyword">for</span> (Hotel hotel : hotels) &#123;</span><br><span class="line">		<span class="comment">//将数据库中的数据转为合适的文档格式</span></span><br><span class="line">		<span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line">		<span class="comment">//创建新文档的Request对象</span></span><br><span class="line">		request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;hotel&quot;</span>)</span><br><span class="line">				.id(hotelDoc.getId().toString())</span><br><span class="line">				.source(JSON.toJSONString(hotelDoc),XContentType.JSON)</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3. 发送请求</span></span><br><span class="line">	client.bulk(request,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
</search>
